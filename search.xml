<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux</title>
      <link href="/2022/04/14/Linux/"/>
      <url>/2022/04/14/Linux/</url>
      
        <content type="html"><![CDATA[<p>🐧画得不够形象，莫得灵魂</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/u=1090189516,820941418&fm=253&fmt=auto&app=138&f=JPEG.webp"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>regularExpressions</title>
      <link href="/2022/04/13/regularExpressions/"/>
      <url>/2022/04/13/regularExpressions/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h1><ul><li>验证密码长度：\d{6,18}$</li><li>验证密码不能使用纯字母或数字：[A-Za-z]+[0-9]</li><li>验证8到16位、必须有小写字母+大写字母+特殊字符+数字组成的密码：(?=^.{8,16}$)(?=.<em>\d)(?=.<em>\W+)(?=.</em>[a-z])(?=.</em>[A-Z])(?!.<em>\n).</em>$</li><li>验证由数字、26个英文字母或下划线组成的字符串：^\w+$</li><li>验证邮编：[1-9]\d{5}</li><li>验证电话号码：(\d{3,4}-)?\d{6,8}$</li><li>验证手机号：[1][3-5]\d{9}$</li><li>验证身份证号：(\d{18}$)|(^\d{15}$)</li><li>验证一年的12个月份：(0?[[1-9]|1[0-2]]$</li><li>验证一个月的31天：((0?[1-9])|((1|2)[0-9])|30|31)$</li><li>验证日期（yyyy-mm-dd）：^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</li><li>验证日期(年-月-日)：(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))</li><li>验证日期(月/日/年) ：[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})</li><li>验证时间(小时:分钟, 24小时制)：((1|0?)[0-9]|2[0-3]):([0-5][0-9])</li><li>验证数字输入： [0-9]*$</li><li>验证非零的正整数：+?[1-9][0-9]*$</li><li>验证非零的负整数：-[1-9][0-9]*$</li><li>验证小数：(-?\d+)(.\d+)?</li><li>验证两位小数：[0-9]+.[0-9]{2}$</li><li>验证金额（精确到2位小数）：^[0-9]+(.[0-9]{2})?$</li><li>验证大写字母：[A-Z]+$</li><li>验证小写字母：[a-z]+$</li><li>验证字母：[A-Za-z]+$</li><li>验证中文汉字：^[\u4e00-\u9fa5]{0,}$</li><li>验证E-mail：[\w!#$%&amp;’<em>+/=?^_<code>&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_</code>{|}~-]+)</em>@(?:<a href="?:%5B%5Cw-%5D*%5B%5Cw%5D">\w</a>?\.)+<a href="?:%5B%5Cw-%5D*%5B%5Cw%5D">\w</a>?</li><li>验证IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</li><li>验证URL：http(s)?://([\w-]+.)+[\w-]+(/[\w- ./?%&amp;=]*)?</li><li>验证QQ号码：[1-9]\d{4,}</li><li>匹配HTML标签：&lt;\/?\w+((\s+\w+(\s*=\s*(?:”.<em>?”|’.*?’|[\^’”&gt;\s]+))?)+\s</em>|\s*)\/?&gt;</li><li>查找CSS属性：^\s*[a-zA-Z\-]+\s*[:]{1}\s[a-zA-Z0-9\s.#]+[;]{1}</li><li>提取页面超链接：(\s*(?!.<em>\brel=)[^&gt;]</em>)(href=”https?:\/\/)((?!(?:(?:www\.)?’.implode(‘|(?:www\.)?’, $follow_list).’))[^”]+)”((?!.<em>\brel=)[^&gt;]</em>)(?:[^&gt;]*)&gt;</li><li>提取网页图片：\&lt; <em>[img][^\&gt;]</em>[src] *= <em>[\“\‘]{0,1}([^\“\‘\ &gt;]</em>)</li><li>提取URL链接：^(f|ht){1}(tp|tps):\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&amp;=]*)?</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>immortal</title>
      <link href="/2022/04/12/immortal/"/>
      <url>/2022/04/12/immortal/</url>
      
        <content type="html"><![CDATA[<h1 id="The-immortal"><a href="#The-immortal" class="headerlink" title="The immortal"></a>The immortal</h1><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/immortal.png" alt="微信图片_20220412192239"></p><p>在这里纪念一下恭喜我又又又又又重回冠绝了，暑假的时候没认真上分，开学又瞎jb乱打，一度掉到5000分，重新定位10把55开。然后就是一路浮沉，也就周末的时候能认真打打。总算是可以开始认真学习了吧？(大概)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装docker</title>
      <link href="/2022/04/08/Centos7InstallDocker/"/>
      <url>/2022/04/08/Centos7InstallDocker/</url>
      
        <content type="html"><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/04/08/docker/"/>
      <url>/2022/04/08/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是Docker，用它来干嘛，为什么要用它等基础介绍转载自阮一峰大佬的文章<a href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></p><p>docker的安装参考 <a href="https://deimos.magi-verse.com/2022/04/08/Centos7InstallDocker/">Centos7下安装docker</a></p><h1 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  # 启动docker服务</span><br><span class="line">systemctl stop docker  # 停止docker服务</span><br><span class="line">systemctl restart docker  # 重启docker服务</span><br></pre></td></tr></table></figure><p>镜像名称:[repository]:[tag]     e.g: mysql:5.7</p><p>镜像相关命令： e.g: docker pull redis ，docker rmi redis</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220411190306000.png" alt="image-20220411190306000"></p><p>容器相关命令（基本都是望文生义）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run  容器名  #创建并运行一个容器</span><br><span class="line">docker pause 容器名/unpause 容器名</span><br><span class="line">docker stop  容器名/start 容器名</span><br><span class="line">docker rm 容器名</span><br><span class="line">docker logs 容器名 -f(跟踪日志输出)</span><br><span class="line">docker ps #查看所有运行中的容器及状态 -a(查看全部容器)</span><br><span class="line">docker exec #进入容器执行命令</span><br></pre></td></tr></table></figure><h1 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h1><p><code>docker run --name 容器名 -p 端口映射 -d     镜像名</code></p><p>-d：后台运行</p><p>-p：端口映射  80:80 宿主端口：容器端口</p><p>进入容器<code>docker exec --it 容器名 bash</code></p><p>-it：给当前进入的容器创建一个标准输入、输出终端、允许我们与容器交互</p><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p><p>但是在容器内修改文件是不推荐的</p><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>数据卷volume是一个虚拟目录，指向宿主机文件系统中的某个目录</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220413141158915.png" alt="image-20220413141158915"></p><p><code>docker volume command</code></p><p>常用数据卷命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker volume create  #创建一个volume</span><br><span class="line">docker volume inspect #显示一个或多个volume信息</span><br><span class="line">docker volume ls   #列出所有volume</span><br><span class="line">docker volume prune #删除未使用的volume</span><br><span class="line">docker volume rm #删除一个或多个指定的volume</span><br><span class="line">docker inspect 数据卷名  #获取容器/镜像的元数据</span><br></pre></td></tr></table></figure><h3 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h3><p>在创建容器时可以通过-v参数来将数据卷挂载到容器中的某个目录(数据卷会自动创建)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name 容器名 -v 宿主机文件(数据卷): 容器内文件</span><br><span class="line">docker run --name mn -v html:/usr/share/nginx/html </span><br></pre></td></tr></table></figure><p>当容器挂载了数据卷，即可在容器外修改容器内容(它们是双向绑定)</p><p>想知道容器内的文件位置可以到dockerhub官方文档查找</p><p>docker volume inspect 容器名 #查看数据卷位置</p><p>在cd到该目录 vim修改文件</p><h1 id="Dockerfile自定义镜像"><a href="#Dockerfile自定义镜像" class="headerlink" title="Dockerfile自定义镜像"></a>Dockerfile自定义镜像</h1><ul><li>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成</li></ul><p>镜像是分层结构，包括基础镜像BaseImage、入口Entrypint、其他依赖和安装程序</p><p>基础镜像可以是操作系统、也可以是别人制作好的镜像</p><p><img src="/2022/04/08/docker/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220416160456909.png" alt="image-20220416160456909"></p><p>其他语法，文档：<a href="https://blog.csdn.net/qq_42896653/article/details/122010894">Dockerfile 参考文档中文版</a></p><p>docker bulid -t 构建好的镜像名 Dockerfile所在的目录 </p><p>e.g: docker bulit -t javaweb:1.0 .            #注意这个.表示所需的Dockerfile所在的目录</p><p>构建好后docker images 即可看到 javaweb1.0</p><h1 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h1><ul><li>Docker Compose可以基于Compose文件帮助我们快速部署分布式应用，无需手动逐个创建和运行容器</li><li>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行，形式如下图(两种方式)：</li><li>DockerCompose的安装参考 <a href="https://deimos.magi-verse.com/2022/04/08/Centos7InstallDocker/">Centos7下安装docker</a></li></ul><p><img src="/2022/04/08/docker/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220419144135241.png" alt="image-20220419144135241"></p><p>dockercompose里的服务之间都可以用服务名访问</p><p>mysql挂载数据卷时指定的路径 $PWD 和 . 的区别</p><p>WARNING: The PWD variable is not set. Defaulting to a blank string.</p><p>将之前写的微服务项目用DockerCompose部署</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/04/06/Git/"/>
      <url>/2022/04/06/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git最简单的使用流程"><a href="#Git最简单的使用流程" class="headerlink" title="Git最简单的使用流程"></a>Git最简单的使用流程</h1><p>安装和部署在各种编译软件上的过程就不再赘述了，百度都有相应的教程，这里默认安装好了git。</p><p>在当前文件夹右键打开Git Bash：</p><p>git init 命令用于在目录中创建新的 Git 仓库</p><p>复制自己的仓库只需 git clone <a href="https://github.com/dullandmeanless/dullandmeanless.github.io.git">https://github.com/dullandmeanless/dullandmeanless.github.io.git</a></p><p>复制别人的仓库先fork到自己的仓库中，修改完再git request向仓库原主人发请求</p><p>git add <filename></filename></p><p>想要撤回本次add，可以git reset  head <filename> </filename></p><p>git commit -m <message></message></p><p>执行commit后，还没执行push时，想要撤销这次的commit，该怎么办？</p><p>解决方案： 使用命令：git reset –soft HEAD^ (–soft表示不删除工作空间的改动代码，–hard 删除工作空间的改动代码、^表示上一个版本，HEAD~2表示撤回上两个版本的commit)</p><p>另外一点，如果commit注释写错了，先要改一下注释，有其他方法也能实现，如：git commit –amend 这时候会进入vim编辑器，修改完成你要的注释后保存即可。</p><p>git push</p><h1 id="fork和clone的区别-fetch与pull的区别"><a href="#fork和clone的区别-fetch与pull的区别" class="headerlink" title="fork和clone的区别,fetch与pull的区别"></a>fork和clone的区别,fetch与pull的区别</h1><p>fork：在github页面，点击fork按钮。将别人的仓库复制一份到自己的仓库。</p><p>clone：将github中的仓库克隆到自己本地电脑中</p><p>问题：pull request的作用</p><p>比如在仓库的主人（A）没有把我们添加为项目合作者的前提下，我们将A的某个仓库名为“a”的仓库clone到自己的电脑中，在自己的电脑进行修改，但是我们会发现我们没办法通过push将代码贡献到B中。</p><p>所以要想将你的代码贡献到B中，我们应该：</p><ol><li>在A的仓库中fork项目a （此时我们自己的github就有一个一模一样的仓库a，但是URL不同）</li><li>将我们修改的代码push到自己github中的仓库B中</li><li>pull request ，主人就会收到请求，并决定要不要接受你的代码</li><li>也可以可以申请为项目a的contributor，这样可以直接push</li></ol><p>(2) fork了别人的项目到自己的repository之后，别人的项目更新了，我们fork的项目怎么更新？</p><p>答：首先fetch网上的更新到自己的项目上，然后再判断、merge。这里就涉及了下一个问题，pull和fetch有啥区别。</p><p> （3）fetch+merge与pull效果一样。但是要多用fetch+merge，这样可以检查fetch下来的更新是否合适。pull直接包含了这两步操作，如果你觉得网上的更新没有问题，那直接pull也是可以的。</p><p> git revert 和 git reset的区别</p><ul><li>git revert 用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；</li><li>git reset 回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</li></ul><h1 id="如何撤销-Git-操作？"><a href="#如何撤销-Git-操作？" class="headerlink" title="如何撤销 Git 操作？"></a>如何撤销 Git 操作？</h1><p>转载自<a href="https://ruanyifeng.com/blog/2019/12/git-undo.html%EF%BC%8C%E5%9C%A8%E4%B8%8A%E7%BD%91%E5%AD%A6%E4%B9%A0Git%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%97%B6%EF%BC%8C%E5%B1%85%E7%84%B6%E5%8F%88%E6%89%BE%E5%88%B0%E4%BA%86%E9%98%AE%E4%B8%80%E5%B3%B0%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%BB%96%E5%86%99%E5%BE%97%E5%AE%9E%E5%9C%A8%E6%98%AF%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%EF%BC%8C%E6%88%91%E4%B8%AA%E4%BA%BA%E5%86%8D%E5%8E%BB%E6%80%BB%E7%BB%93%E8%BF%99%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C%E4%B9%9F%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8(%E6%9C%89%E5%88%A0%E6%94%B9)%EF%BC%9A">https://ruanyifeng.com/blog/2019/12/git-undo.html，在上网学习Git的相关知识时，居然又找到了阮一峰大佬的文章，由于他写得实在是浅显易懂，我个人再去总结这部分操作也没有意义，这里直接引用(有删改)：</a></p><h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#x27;xxx&#x27;                                       # 提交</span><br><span class="line">git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features/performance                         # 检出已存在的features/performance分支</span><br><span class="line">git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT                # 清理不必要的文件并优化本地存储库</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发</title>
      <link href="/2022/03/29/Multithreading/"/>
      <url>/2022/03/29/Multithreading/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/03/28/Redis/"/>
      <url>/2022/03/28/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis是一款key-value存储结构的内存级NoSQL数据库"><a href="#Redis是一款key-value存储结构的内存级NoSQL数据库" class="headerlink" title="Redis是一款key-value存储结构的内存级NoSQL数据库"></a>Redis是一款key-value存储结构的内存级NoSQL数据库</h1><h2 id="windows版本"><a href="#windows版本" class="headerlink" title="windows版本"></a>windows版本</h2><p>在其安装目录中打开命令行启动服务端：<br><code>redis-server.exe redis.windows.conf</code></p><p>在新的命令窗口启动客户端：<code>redis-cli</code> 开始进行数据库操作</p><p>set name value               set name zzw</p><p>get name                               zzw</p><p>hset key field value             hset keya a1 zzw</p><p>hget key field                       hget keya a1                    zzw</p><h2 id="Spring-Boot整合Redis"><a href="#Spring-Boot整合Redis" class="headerlink" title="Spring Boot整合Redis"></a>Spring Boot整合Redis</h2><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用时添加操作Redis接口对象 RedisTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="type">ValueOperations</span> <span class="variable">ops</span> <span class="operator">=</span> redisTemplate.opsForValue(); </span><br><span class="line">    ops.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;value&quot;</span>);       </span><br><span class="line">    ops.get(<span class="string">&quot;name&quot;</span>);                </span><br></pre></td></tr></table></figure><h3 id="在客户端操作redis是以字符串的形式"><a href="#在客户端操作redis是以字符串的形式" class="headerlink" title="在客户端操作redis是以字符串的形式"></a>在客户端操作redis是以字符串的形式</h3><h3 id="在SpringBoot中操作用RedisTemplate是以对象的形式"><a href="#在SpringBoot中操作用RedisTemplate是以对象的形式" class="headerlink" title="在SpringBoot中操作用RedisTemplate是以对象的形式"></a>在SpringBoot中操作用RedisTemplate是以对象的形式</h3><h3 id="要想保持一致-使用StringRedisTemplate接口对象-常用"><a href="#要想保持一致-使用StringRedisTemplate接口对象-常用" class="headerlink" title="要想保持一致 使用StringRedisTemplate接口对象(常用)"></a>要想保持一致 使用StringRedisTemplate接口对象(常用)</h3><h1 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h1><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件中启用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: <span class="number">6379</span></span><br><span class="line">      client-type: jedis</span><br></pre></td></tr></table></figure><h3 id="与lettcus的区别"><a href="#与lettcus的区别" class="headerlink" title="与lettcus的区别"></a>与lettcus的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220329160216629.png" alt="image-20220329160216629"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb(Windows)</title>
      <link href="/2022/03/28/Mongodb/"/>
      <url>/2022/03/28/Mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="Mongodb是一个开源、高性能、无模式的文档型数据库"><a href="#Mongodb是一个开源、高性能、无模式的文档型数据库" class="headerlink" title="Mongodb是一个开源、高性能、无模式的文档型数据库"></a>Mongodb是一个开源、高性能、无模式的文档型数据库</h1><p>启动服务端在bin目录命令行输入：mongod –dbpath=..\data\db         指定存放位置</p><p>客户端启动： mogo –host=127.0.0.1 –port=27017</p><p>当注册到本地服务后就不用那么麻烦</p><p>可视化工具 Robo3T</p><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>db.表名.insert/save({“name”:”springboot”})</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>db.表名.find()  //查询全部</p><p>db.表名.find({name:”xxxx”})  //查询条件</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>db.表名.remove({条件})  </p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>db.表名.update({name:”要修改的”},{$set:{name:”修改成”}})   //改符合条件的第一条</p><p>db.表名.updatemany</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220329163400255.png" alt="image-20220329163400255"></p><h1 id="Spring-Boot整合Mongodb"><a href="#Spring-Boot整合Mongodb" class="headerlink" title="Spring Boot整合Mongodb"></a>Spring Boot整合Mongodb</h1><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      uri: mongodb:<span class="comment">//localhost/test    指定数据库名</span></span><br></pre></td></tr></table></figure><p>使用时添加操作mongodb的接口对象MongoTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MongoTemplate mt;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">       book b=<span class="keyword">new</span> <span class="title class_">book</span>();</span><br><span class="line">       b.setId(<span class="number">2</span>);b.setName(<span class="string">&quot;西游记&quot;</span>);b.setPublishTime(<span class="number">1222</span>);b.setUuid(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">           mt.save(b);&#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;book&gt; all = mt.findAll(book.class);</span><br><span class="line">       System.out.println(all);&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud</title>
      <link href="/2021/10/03/SpringCloud/"/>
      <url>/2021/10/03/SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><strong>优点：</strong>架构简单，部署成本低  </p><p><strong>缺点：</strong>耦合度高（维护困难、升级困难）</p></li><li><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><strong>优点：</strong>降低服务耦合，有利于服务升级和拓展</p><p><strong>缺点：</strong>服务调用关系错综复杂</p></li></ul><p>微服务的架构特征：</p><ul><li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</p></li><li><p>自治：团队独立、技术独立、数据独立，独立部署和交付</p></li><li><p>面向服务：服务提供统一标准的接口，与语言和技术无关</p></li><li><p>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p></li></ul><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Spring-Cloud-1"><a href="#Spring-Cloud-1" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220323213604059.png" alt="image-20220323213604059"></p><p>注意Spring Cloud和Spring Boot 有版本兼容关系(截止2022.04)</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220419163420334.png" alt="image-20220419163420334"></p><h1 id="创建Spring-Cloud项目"><a href="#创建Spring-Cloud项目" class="headerlink" title="创建Spring Cloud项目"></a>创建Spring Cloud项目</h1><p>注意在父工程的pom文件设置好Spring Cloud的版本，之后在该父工程下的微服务只需引用即可(省去重复配置的一些东西，比如mybatis、mysql、lombok)</p><p>比如一个父工程testcloud，<strong>依赖配置在<dependencyManagement>&lt;/<dependencyManagement>里面</dependencyManagement></dependencyManagement></strong>    (lombok在外面)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;artifactId&gt;testcloud&lt;/artifactId&gt;  #父工程名</span><br><span class="line">&lt;groupId&gt;com&lt;/groupId&gt;              </span><br><span class="line">&lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;   #用pom格式打包 默认是jar</span><br><span class="line">&lt;modules&gt;                      #挂载的模块</span><br><span class="line">    &lt;module&gt;testServer&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;         #也是通过指定夫工程 来确定Spring Boot版本</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.4&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>在子工程中testServer的pom中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; #指定父工程</span><br><span class="line">    &lt;artifactId&gt;testcloud&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;artifactId&gt;testServer&lt;/artifactId&gt; #自己的工程名</span><br></pre></td></tr></table></figure><p>注意：如果不在父工程配置好，那每个子工程可能都会重复配置一些东西如Spring Cloud版本，不是不可以，就是后续微服务多起来，依赖变多，不好管理</p><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p>Eureka结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220323214259865.png" alt="image-20220323214259865"></p><p>分为服务端和客户端，两者都在父工程下</p><h1 id="EurekaServer服务端配置："><a href="#EurekaServer服务端配置：" class="headerlink" title="EurekaServer服务端配置："></a>EurekaServer服务端配置：</h1><ul><li><p>引入依赖  <code>spring-cloud-starter-netflix-eureka-server</code></p></li><li><p>在启动类添加@EnableEurekaServer注解</p></li><li><p>在配置文件编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">10086</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server <span class="comment">//在注册中心的服务名称</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="comment">//http://127.0.0.1:10086/eureka</span></span><br><span class="line">    register-with-eureka: <span class="literal">true</span> <span class="comment">//是否注册自己</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="EurekaClient客户端配置："><a href="#EurekaClient客户端配置：" class="headerlink" title="EurekaClient客户端配置："></a>EurekaClient客户端配置：</h1><ul><li>引入依赖   <code>spring-cloud-starter-netflix-eureka-client</code></li><li>在启动类添加@EnableEurekaServer注解(可不加，详情参考<a href="https://blog.csdn.net/sunxy24/article/details/105686511">https://blog.csdn.net/sunxy24/article/details/105686511</a>)</li><li>在配置文件编写：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: orderservice <span class="comment">//在注册中心的服务名称</span></span><br><span class="line">#  pattern:</span><br><span class="line">#    dateformat: MM-dd HH:mm:ss:SSS</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span></span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//127.0.0.1:10086/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务远程调用"><a href="#服务远程调用" class="headerlink" title="服务远程调用"></a>服务远程调用</h1><p>在服务调用类的启动类添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span> <span class="comment">//负载均衡</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改业务层的代码，修改访问的url路径，用服务名代替ip、端口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restTemplate.getForObject(<span class="string">&quot;http://userservice/user/&quot;</span>+ order.getUserId(), xxx.class);   xxx为返回的类型</span><br></pre></td></tr></table></figure><h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220323233535532.png" alt="image-20220323233535532"></p><p>默认负载均衡是ZoneAvoidanceRule，轮询</p><p>通过定义IRule实现可以修改负责均衡规则，要在RestTemplate上添加@LoadBalanced</p><p>代码方式，在服务调用类的启动类中定义一个新的IRule：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;   <span class="comment">//不同策略对应不同的类名</span></span><br></pre></td></tr></table></figure><p>配置文件方式：在服务调用类的配置文件中，添加配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice(调用的服务名称):</span><br><span class="line">   ribbon:</span><br><span class="line">      NFLoadBBalancerRuleClassName: com.netflix.loadbalancer.RandonRule </span><br></pre></td></tr></table></figure><p>Ribbon默认采用懒加载，即在第一次访问时采取创建LoadBalanceClient</p><p>饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过在服务调用类的配置文件添加配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    clients: userservice  #指定对服务名称为userservice饥饿加载</span><br></pre></td></tr></table></figure><h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>在nacos的bin文件目录下命令行输入：<code>startup.cmd -m standalone</code>单机启动nacos 默认端口8848</p><p>在父工程中添加spring-cloud-alibaba管理依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.5</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在客户端添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Nacos服务分级存储-服务→集群→实例"><a href="#Nacos服务分级存储-服务→集群→实例" class="headerlink" title="Nacos服务分级存储 服务→集群→实例"></a>Nacos服务分级存储 服务→集群→实例</h3><p>在客户端添加nacos地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring：</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      discovery：</span><br><span class="line">        cluster-name：xx <span class="comment">//配置集群名称</span></span><br></pre></td></tr></table></figure><p>配置负载均衡规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:      <span class="comment">//要做配置的微服务名称</span></span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule <span class="comment">//集群优先 然后随机</span></span><br></pre></td></tr></table></figure><h3 id="Nacos控制台可以控制实例的权重值-0-1"><a href="#Nacos控制台可以控制实例的权重值-0-1" class="headerlink" title="Nacos控制台可以控制实例的权重值(0-1)"></a>Nacos控制台可以控制实例的权重值(0-1)</h3><h2 id="环境隔离-namespace"><a href="#环境隔离-namespace" class="headerlink" title="环境隔离-namespace"></a>环境隔离-namespace</h2><p>在Nacos控制台创建namespace，用来隔离不同环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery: 命名空间的id</span><br></pre></td></tr></table></figure><p>不同namespace下的服务不可见</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220326152043273.png" alt="image-20220326152043273"></p><p>服务注册到Naocs时，可以选择注册为临时或非临时实例，在配置文件添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        ephemeral: <span class="literal">false</span> /设置为非临时实例</span><br></pre></td></tr></table></figure><h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><p>在nacos控制台新建配置(注意命名空间) 格式为 name-profile.yaml</p><p>添加nacos的config依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>添加bootstrap.yml，配置：服务名称、开发环境、文件后缀名，三者指定在Nacos中的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: userservice</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml</span><br></pre></td></tr></table></figure><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><ul><li> 方式一：在@Value注入的变量所在的类上添加注解@RefreshScope</li><li>方式二：把配置注册到一个Bean对象里面<img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220328210934981.png" alt="image-20220328210934981"></li></ul><p>注意要和配置文件中的属性一一对应</p><h2 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享</h2><p>多种配置的优先级：服务名-profile.yaml→服务名.yaml→本地配置</p><h1 id="Feign代替RestTemplate远程调用"><a href="#Feign代替RestTemplate远程调用" class="headerlink" title="Feign代替RestTemplate远程调用"></a>Feign代替RestTemplate远程调用</h1><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在要进行远程调用的<strong>启动类</strong>添加注解</p><p><code>@EnableFeignClients</code></p><p>编写Feign客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span> <span class="comment">//要远程调用的服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span> <span class="comment">//请求的路径</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现业务逻辑时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">userClient.findById(id); <span class="comment">//直接调用接口里的方法</span></span><br></pre></td></tr></table></figure><h3 id="Feign集合了Ribbon-默认实现负载均衡"><a href="#Feign集合了Ribbon-默认实现负载均衡" class="headerlink" title="Feign集合了Ribbon 默认实现负载均衡"></a>Feign集合了Ribbon 默认实现负载均衡</h3><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="配置Feign日志"><a href="#配置Feign日志" class="headerlink" title="配置Feign日志"></a>配置Feign日志</h2><ul><li><p>配置文件方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      <span class="keyword">default</span>:       #<span class="keyword">default</span>默认为全局配置，如果写服务名称，则针对该服务名称进行配置</span><br><span class="line">        loggerLevel: BASIC #日志级别 none basic header full</span><br></pre></td></tr></table></figure></li><li><p>java代码当时，首先声明一个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClientConfiguration</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Logger.Level.BASIC;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局配置，<strong>启动类</strong>添加注释<code>@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)</code></p><p>局部配置，<strong>启动类</strong>添加注释<code>@FeignClient(value =&quot;服务名称&quot; ,configuration = FeignClientConfiguration)</code></p></li></ul><h2 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h2><p>Feign底层的客户端实现：</p><ul><li><p>URLConnection：默认实现，不支持连接池</p></li><li><p>Apache HeepClient：支持连接池</p></li><li><p>OKHttp：支持连接池 </p></li></ul><h3 id="Feign添加HttpClient的支持："><a href="#Feign添加HttpClient的支持：" class="headerlink" title="Feign添加HttpClient的支持："></a>Feign添加HttpClient的支持：</h3><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件配置连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  httpclient:</span><br><span class="line">    enable: <span class="literal">true</span> #开关</span><br><span class="line">    max-connections: <span class="number">200</span>  #最大连接数</span><br><span class="line">    max-connections-per-route: <span class="number">50</span> #单个路径最大连接数    </span><br></pre></td></tr></table></figure><h2 id="抽取FeignClient"><a href="#抽取FeignClient" class="headerlink" title="抽取FeignClient"></a>抽取FeignClient</h2><p>创建一个module，feign-api，引入依赖</p><p>里面有client、pojo、DefaultConfigurationD(java代码形式)</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220401201204884.png" alt="image-20220401201204884"></p><p>当定义的FeignClient不在<strong>SpringBootAplication启动类</strong>的扫描包范围时，这些FeignClient无法使用</p><p>解决方法一：指定FeignClient所在包</p><p>启动类添加注解<code>@EnableFeignClients(basePackages = &quot;包名&quot;)</code></p><p>解决方法二：指定FeignClient字节码</p><p>启动类添加注解<code>@EnableFeignClients(clients =&#123;UserClient.class&#125;)</code></p><h1 id="统一网关Gateway"><a href="#统一网关Gateway" class="headerlink" title="统一网关Gateway"></a>统一网关Gateway</h1><p>网关功能：</p><ul><li>身份验证和权限校验</li><li>服务路由、负载均衡</li><li>请求限流</li></ul><p>添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--nacos服务注册发现依赖--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;!--网关gateway依赖--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件编写路由配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: nacos:8848 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: user-service # 路由标示，必须唯一</span><br><span class="line">          uri: lb://userservice # 路由的目标地址</span><br><span class="line">          predicates: # 路由断言，判断请求是否符合规则</span><br><span class="line">            - Path=/user/** # 路径断言，判断路径是否是以/user开头，如果是则符合</span><br><span class="line">            - After=   #断言规则</span><br><span class="line">#         filters:     # 过滤器 只针对该路由</span><br><span class="line">        - id: order-service</span><br><span class="line">          uri: lb://orderservice</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/order/**</span><br><span class="line">#      default-filters:      #  默认过滤器,会对所有的路由请求都生效</span><br><span class="line">#       - AddRequestHeader=Truth,Itcast is freaking awesome!</span><br></pre></td></tr></table></figure><ul><li><p>在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory(断言工厂)读取并处理，转变为路由判断的条件</p></li><li><p>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类</p><p><img src="https://cdn.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220407194237442.png" alt="image-20220407194237442"></p></li></ul><h2 id="路由过滤器GatewayFilter"><a href="#路由过滤器GatewayFilter" class="headerlink" title="路由过滤器GatewayFilter"></a>路由过滤器GatewayFilter</h2><p>可以对网关的请求和微服务返回的响应做处理</p><p>Spring提供了31种不同的路由过滤器工厂,<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p><p>如何在配置文件里配置,参考上面的路由配置</p><h2 id="全局过滤器GlobalFilter"><a href="#全局过滤器GlobalFilter" class="headerlink" title="全局过滤器GlobalFilter"></a>全局过滤器GlobalFilter</h2><p>处理一切进入网关的请求和微服务返回的响应,GatewayFilter通过配置定义,GlobalFilter的逻辑需要手写代码实现,定义方法是实现GlobalFilter接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="comment">//order越小优先级越高</span></span><br><span class="line"><span class="comment">// @Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取参数中的 authorization 参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.判断参数值是否等于 admin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 4.是，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.否，拦截</span></span><br><span class="line">        <span class="comment">// 5.1.设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">// 5.2.拦截请求</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器执行顺序</p><p>每一个过滤器都必须指定一个int类型的order值,order越小优先级越高</p><p>路由过滤器和默认过滤器的order由Spring指定,默认是按照声明顺序从1递增</p><p>当过滤器的order值一样值,会按照默认过滤器&gt;路由过滤器&gt;全局过滤器的顺序执行</p><h1 id="跨域问题处理"><a href="#跨域问题处理" class="headerlink" title="跨域问题处理"></a>跨域问题处理</h1><p>跨域问题:浏览器禁止请求的发起者与服务端发生跨域ajax请求,请求会被浏览器拦截,它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。</p><p>例如：a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是<strong>浏览器的限制</strong>。理解这一点很重要！！</p><p> Gateway网关处理跨域采用的同样是CORS方案,并且只需要简单配置即可实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      globalcors:  # 全局的跨域处理</span><br><span class="line">        add-to-simple-url-handler-mapping: true # 解决option请求被拦截问题</span><br><span class="line">        cors-configurations:</span><br><span class="line">          &#x27;[/**]&#x27;:</span><br><span class="line">            allowedOrigins: #允许哪些网站的跨域请求</span><br><span class="line">              - &quot;http://www.baidu.com&quot;</span><br><span class="line">              - &quot;http://localhost:8090&quot;</span><br><span class="line">            allowedMethods: #允许的跨域ajax的请求方式</span><br><span class="line">              - &quot;GET&quot;</span><br><span class="line">              - &quot;POST&quot;</span><br><span class="line">              - &quot;DELETE&quot;</span><br><span class="line">            allowedHeaders: &quot;*&quot; # 允许在请求头中携带的信息</span><br><span class="line">            allowedCredentials: true # 是否允许携带cookie</span><br><span class="line">            maxAge: 360000 #这次跨域检测的有效期</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring、Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 开发知识</title>
      <link href="/2021/10/03/SpringBoot-dev/"/>
      <url>/2021/10/03/SpringBoot-dev/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>web环境模拟测试</p><p>@SpringBootTest(webEnvironment = SrpingBootTest.Webvironment.***) 启动虚拟环境</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220308145421445.png" alt="image-20220308145421445"></p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220308163200419.png" alt="image-20220308163200419"></p><p>生成随机数据</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220308200357559.png" alt="image-20220308200357559"></p><p>@EnableCaching启用缓存</p><p>@Cacheable(value=””,key=”#”)将当前数据加入到缓存</p><p>Quartz</p><p>Quartz的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.MyQuartz;</span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//工作明细</span></span><br><span class="line">    <span class="keyword">public</span> JobDetail <span class="title function_">jd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//MyQuartz是具体工作</span></span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(MyQuartz.class).storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//触发器将工作明细和调度器绑定 </span></span><br><span class="line">    <span class="keyword">public</span> Trigger <span class="title function_">tri</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调度器</span></span><br><span class="line">        ScheduleBuilder scheduleBuilder=CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/5 * * * * ?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger().forJob(jd()).withSchedule(scheduleBuilder).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Task</p><p>@EnableScheduling 开启定时任务功能</p><p>在要执行定时任务的方法上@Scheduled(cron =””)  在配置文件可以配task的相关配置</p><p>Spring Boot Admin 监控</p><p>在Admin Server中的启动类配置@EnableAdminServer</p><p>客户端的配置文件</p><p>management-endpoint-health-show-details：always</p><p>management-endpoint-端点名-enabled-: t/f设置端点对外开发信息</p><p>management-endpoints-web-exposure-include:”*” 将所有端点暴露给web端</p><p>Admin Server服务端通过actuator下的各种映射方法获取端点信息并展示</p><p>​           jconsole</p><p>在配置文件中为info端点配置信息</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319153708822.png" alt="image-20220319153708822"></p><p>写一个配置类AppInfoContributor为info端点增添指标信息</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319153724076.png" alt="image-20220319153724076"></p><p>同理，写一个配置类AppHealthContributor为health端点增添指标信息</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319154526544.png" alt="image-20220319154526544"></p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319160909206.png" alt="image-20220319160909206"></p><p>即在这添加具体的监听</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319161116393.png" alt="image-20220319161116393"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 运维知识</title>
      <link href="/2021/09/28/SpringBoot-om/"/>
      <url>/2021/09/28/SpringBoot-om/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot基础知识</title>
      <link href="/2021/09/26/SpringBoot-basic/"/>
      <url>/2021/09/26/SpringBoot-basic/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="/2021/09/23/java/"/>
      <url>/2021/09/23/java/</url>
      
        <content type="html"><![CDATA[<p>CAP原则又称CAP定理，指的是在一个分布式系统中，<a href="https://baike.baidu.com/item/%E4%B8%80%E8%87%B4%E6%80%A7/9840083">一致性</a>（Consistency）、<a href="https://baike.baidu.com/item/%E5%8F%AF%E7%94%A8%E6%80%A7/109628">可用性</a>（Availability）、<a href="https://baike.baidu.com/item/%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7/23734073">分区容错性</a>（Partition tolerance）。CAP 原则指的是，这三个<a href="https://baike.baidu.com/item/%E8%A6%81%E7%B4%A0/5261200">要素</a>最多只能同时实现两点，不可能三者兼顾。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HexoBlog建站流程</title>
      <link href="/2021/09/21/HexoBlog/"/>
      <url>/2021/09/21/HexoBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-GitHub-搭建个人博客"><a href="#Hexo-GitHub-搭建个人博客" class="headerlink" title="Hexo+GitHub 搭建个人博客"></a>Hexo+GitHub 搭建个人博客</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>最近看到了同学写的个人网站<a href="https://magidrag0n.github.io/">https://magidrag0n.github.io/</a>  ，感觉很有意思，便打算自己也弄一个玩玩，虽然参考了同学写的教程<a href="https://magidrag0n.github.io/2020/07/16/HexoBlog-OnlineInTen/">https://magidrag0n.github.io/2020/07/16/HexoBlog-OnlineInTen/</a>   和网上的教程，但还是踩了不少雷，这里再总结一下教程，提醒自己也方便下大家。</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="GitHub-Pages-是什么？"><a href="#GitHub-Pages-是什么？" class="headerlink" title="GitHub Pages 是什么？"></a>GitHub Pages 是什么？</h3><ul><li><a href="https://link.zhihu.com/?target=https://help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h3 id="Hexo-是什么？"><a href="#Hexo-是什么？" class="headerlink" title="Hexo 是什么？"></a>Hexo 是什么？</h3><ul><li>官网：<a href="https://link.zhihu.com/?target=https://hexo.io/zh-cn/">hexo.io</a></li></ul><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><h3 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a>Hexo + GitHub 文章发布原理</h3><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>Node.js是一个让JavaScript运行在服务端的开发平台,用它可以方便地搭建响应速度快、易于扩展的网络应用</p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm(Node Package Manager)其实就是包管理工具，对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>需要用到Github账号、node.js、npm</p></li><li><p>新版的Node.js已自带npm</p><p>安装完毕后在命令行输入:node -v，检查是否成功安装、命令行中输入 npm -v，检查 npm 包管理器是否存在</p><p>如果显示’xxx’ 不是内部或外部命令，也不是可运行的程序或批处理文件时。请将node.js加入系统变量，或直接在命令前加上npx，npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。如果模块存在，就使用。如果不存在，就临时下载，用完就删除。</p></li><li><p>安装hexo博客框架</p><p>首先将命令行当前文件夹切换到一个新的空文件夹 (不建议中文) 当中</p><p>然后在命令行中输入：<code>npm install -g hexo-cli</code></p></li><li><p>安装 Git 推送套件：</p><p>在你创好的放hexo框架的文件夹中打开cmd(没特别说明后文的所有指令都是在此路径执行)，在命令行输入:<code>npm install --save hexo-deployer-git</code>。Tips：安装完成后会有一项 Warning 提醒，不用担心，敬请忽略</p></li><li><h3 id="快速开始："><a href="#快速开始：" class="headerlink" title="快速开始："></a>快速开始：</h3><p>命令行中输入：</p><p><code>hexo init</code>  (报错请尝试在前面加npx，后面所有关于hexo的命令都可以加npx)</p><p>此步骤会自动克隆一个 Landscape 的主题博客，并且你将在你的博客目录下看到自动生成的文件</p><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul></li><li><h3 id="启动本地博客服务器："><a href="#启动本地博客服务器：" class="headerlink" title="启动本地博客服务器："></a>启动本地博客服务器：</h3><p>在命令行中输入：</p><p><code>hexo generate</code>  # 生成静态页面，可以用hexo g缩写</p><p><code>hexo server</code>  # 启动预览，可以用hexo s缩写</p><p>将会提示你：</p><p><code>INFO Start processing.</code><br><code>INFO Hexo is running at http://localhost:4000.Press Ctrl+C to stop.</code></p><p>表示我们的博客已经部署到本地服务器上了，此时在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 便可查看你的博客！</p><p><img src="/2021/09/21/HexoBlog/3.jpg"></p><p>其中的自带的博文包含了一些简易的操作指令与讲解</p><p><strong>Tips：</strong>如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo s -p 5000</code> 更改端口号后重试。</p><h2 id="Hexo-的-Github-上线"><a href="#Hexo-的-Github-上线" class="headerlink" title="Hexo 的 Github 上线"></a>Hexo 的 Github 上线</h2><p>刚才建立的网站只能在本地服务器中查看，即便拿出手机输入相同网址亦是不能查看的。我们需要让好朋友们看到我们的网站，就需要将博客服务器从本地局域服务器推送到云端服务器，我们可以用GitHub Pages来完成，让所有人都可以访问。</p><ul><li><p>使用你刚才创建的Github账户，在主页右上角找到新建项目<strong>New repository</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide1.png"></p><p>并建立一个与你名称相同前缀的项目名**(YourName.github.io)**</p><p>此处因为我已经创建过所以不能重复创建，你可直接点 <strong>Create repository</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide2.png"></p><p><img src="/2021/09/21/HexoBlog/2.png"></p><p>在创建好的仓库中点击Settings，选择Pages，在Source下可以选择你Github Pages所需的资源从哪里来。注:如果修改成main，在_config.yml文件末端要同步修改成branch: main。</p></li><li><h3 id="配置Git推送套件"><a href="#配置Git推送套件" class="headerlink" title="配置Git推送套件"></a>配置Git推送套件</h3><p>打开你创建的博客目录文件夹，找到_config.yml这个文件并打开编辑</p><p><img src="https://cdn.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide3.png"></p><p>在代码末尾添加：</p><p><code>deploy:</code></p><p> <code>type: &#39;git&#39;</code></p><p> <code>repo: &quot;https://github.com/你的名字/你的名字.github.io.git&quot;</code></p><p> <code>branch: &quot;master&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide4.png"></p><p>至此Git推送套件已准备就绪</p><p>git有时会抽风，上传不到master分支，可以换成main分支，再修改GitHub Pages中的对应内容</p></li></ul></li><li><p>第一次使用GIt要先在命令行中输入：</p><p><code>git config --global user.email &quot;you@example.com&quot;</code>  (你的Github邮箱)<br><code>git config --global user.name &quot;Your Name&quot;</code>  (你的Github名称)</p><p>然后输入<code>hexo deploy</code> 部署文章，也可以用缩写hexo d</p><p>此时会哗啦啦流淌一行行提示，并会让你输入你的Github名称与密码</p><p>当提示结束时，便可进入网页 你的名称.github.io 查看你的博客啦！</p><p>如果输入hexo d报错，有可能是当前网络链接不太好，可以多试几次和清除代理或翻墙</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li><h3 id="博客内容的倡议"><a href="#博客内容的倡议" class="headerlink" title="博客内容的倡议"></a>博客内容的倡议</h3></li></ul><p>不能传播危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的内容。</p><p>不能散布谣言，扰乱社会秩序，破坏社会稳定。</p><p>不能散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪。</p><p>不能侮辱或者诽谤他人，侵害他人合法权益。</p><p>——《互联网信息服务管理办法》节选</p><h4 id="我们要约束自己的行为，因为这关乎所有人的互联网自由。"><a href="#我们要约束自己的行为，因为这关乎所有人的互联网自由。" class="headerlink" title="我们要约束自己的行为，因为这关乎所有人的互联网自由。"></a><strong>我们要约束自己的行为，因为这关乎所有人的互联网自由。</strong></h4><ul><li><h3 id="博客访问地址"><a href="#博客访问地址" class="headerlink" title="博客访问地址"></a>博客访问地址</h3><p><a href="https://localhost:4000/">https://localhost:4000</a>  (本地服务器开启可访问)</p><p><a href>YourName.github.io</a>  (随时随地访问最近一次推送版本的博客)</p></li><li><h3 id="常用Hexo指令"><a href="#常用Hexo指令" class="headerlink" title="常用Hexo指令"></a>常用Hexo指令</h3><p><code>hexo clean</code>  (清除缓存)</p><p><code>hexo g</code>  (迭代博客内容，每次编辑后操作)</p><p><code>hexo d</code>  (推送至github服务器)</p><p><code>hexo new page &quot;XXX&quot;</code>  (新建一个名为XXX的页面)</p><p><code>hexo new &quot;title&quot;</code>  (新建一个名为title的文章)</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
