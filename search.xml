<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis-Plus-Lambda</title>
      <link href="/2022/08/27/MyBatis-Plus-Lambda/"/>
      <url>/2022/08/27/MyBatis-Plus-Lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-Plus之四种lambda方式"><a href="#Mybatis-Plus之四种lambda方式" class="headerlink" title="Mybatis-Plus之四种lambda方式"></a>Mybatis-Plus之四种lambda方式</h1><p>Mybatis-Plus之四种lambda方式<br>lambda四种表达形式</p><h1 id="LambdaQueryWrapper，QueryWrapper＜实体＞-lambda-，LambdaQueryChainWrapper＜实体＞"><a href="#LambdaQueryWrapper，QueryWrapper＜实体＞-lambda-，LambdaQueryChainWrapper＜实体＞" class="headerlink" title="LambdaQueryWrapper，QueryWrapper＜实体＞().lambda()，LambdaQueryChainWrapper＜实体＞"></a>LambdaQueryWrapper，QueryWrapper＜实体＞().lambda()，LambdaQueryChainWrapper＜实体＞</h1><p>前言<br>使用了lambda表达式 可以通过方法引用的方式来使用实体字段名的操作，避免直接写数据库表字段名时的错写名字；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>V2ray</title>
      <link href="/2022/07/01/V2ray/"/>
      <url>/2022/07/01/V2ray/</url>
      
        <content type="html"><![CDATA[<p>本教程为个人搭建V2ray翻墙节点的教程，耐心看完30分钟内就可以假设好！</p><p>首先准备VPS，这个自己网上找找有很多<br>个人推荐bwh81.net的洛杉矶VPS<br>线路为CN2 GIA速度很不错，晚高峰时段油管8K毫无压力，价格相比较其他日本、韩国、台湾、香港CN2线路的VPS便宜太多了，50刀1年<br>当然也可以用用普通线路的VPS，价格更便宜，不过普通线路嘛，一到晚高峰就生活无法自理！</p><p>需要工具：Xshell、v2rayN<br>链接: <a href="https://pan.baidu.com/s/1pihGR6ecFzmnqXIy3jMDJQ?pwd=9mm6">https://pan.baidu.com/s/1pihGR6ecFzmnqXIy3jMDJQ?pwd=9mm6</a> 提取码: 9mm6</p><p>首先购买VPS<br>然后使用Xshell连接VPS<br>点击文件-新建<br><img src="/2022/07/01/V2ray/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220701234414055.png" alt="image-20220701234414055"></p><p>输入账号和密码后连接VPS<br><img src="/2022/07/01/V2ray/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220701234429530.png" alt="image-20220701234429530"><br><img src="/2022/07/01/V2ray/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220701234444067.png" alt="image-20220701234444067"></p><p>然后输入一键安装v2ray脚本<br>bash &lt;(curl -s -L <a href="https://git.io/v2ray.sh">https://git.io/v2ray.sh</a>)<br>然后选择安装<br>我这里已经安装好了，端口都是自己定义，传输协议建议使用kcp，伪装类型建议使用dtls，这样不容易被墙<br><img src="/2022/07/01/V2ray/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220701234454666.png" alt="image-20220701234454666"></p><p>接下来就等就行了，安装完成后会v2ray的地址、端口之类的<br>地址 (Address) = xxxxxx</p><p>端口 (Port) = xxxxxx</p><p>用户ID (User ID / UUID) = xxxxxx</p><p>额外ID (Alter Id) = 0</p><p>传输协议 (Network) = xxxxxx</p><p>伪装类型 (header type) = xxxxxx</p><p>接下来安装tcp加速<br>输入 wget -N –no-check-certificate “<a href="https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;">https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</a><br>安装完脚本后输入 chmod +x tcp.sh<br>然后输入 ./tcp.sh</p><p><img src="/2022/07/01/V2ray/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220701234507433.png" alt="image-20220701234507433"></p><p>个人建议使用bbrplus<br>输入数字2<br>等安装完成后重启vps，重启后再次输入 ./tcp.sh，输入数字7，使用bbrplus版加速。<br>这样就完成了v2ray机场的搭建</p><p>下面我们打开v2rayN<br>点击服务器-添加[VMess]服务器<br>只需要输入下图中的信息就可以链接了</p><p><img src="/2022/07/01/V2ray/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220701234519879.png" alt="image-20220701234519879"><br>链接模式个人建议使用PAC模式，在软件目录下有个叫pac.txt的文件，可以自己编辑需要代理的网站或IP，这样就不会影响访问国内网站</p><p>以上就是如何简单搭建v2ray机场的教程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus+Grafana</title>
      <link href="/2022/06/11/Prometheus-Grafana/"/>
      <url>/2022/06/11/Prometheus-Grafana/</url>
      
        <content type="html"><![CDATA[<h1 id="Prometheus-Grafana"><a href="#Prometheus-Grafana" class="headerlink" title="Prometheus+Grafana"></a>Prometheus+Grafana</h1><p>简单的理解：Prometheus是一款基于Spring Cloud构建的开源系统监控和报警工具，而Grafana是它的可视化工具，只需要提供需要监控的数据，它就可你生成各种可视化仪表。同时还有报警功能，可以在系统出现问题时通知用户。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Prometheus的基本架构如下图所示：</p><p><img src="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/blog/16027237814690.jpg" alt="image-20220611213501418"></p><p>从上图可以看到，整个 Prometheus 可以分为四大部分，分别是：</p><ul><li><strong>Prometheus 服务器</strong></li></ul><p>Prometheus Server 是 Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询。</p><ul><li><strong>NodeExporter 业务数据源</strong></li></ul><p>业务数据源通过 Pull/Push 两种方式推送数据到 Prometheus Server。</p><ul><li><strong>AlertManager 报警管理器</strong></li></ul><p>Prometheus 通过配置报警规则，如果符合报警规则，那么就将报警推送到 AlertManager，由其进行报警处理。</p><ul><li><strong>可视化监控界面</strong></li></ul><p>Prometheus 收集到数据之后，由 WebUI 界面进行可视化图标展示。目前我们可以通过自定义的 API 客户端进行调用数据展示，也可以直接使用 Grafana 解决方案来展示。</p><p>简单地说，Prometheus 的实现架构也并不复杂。<strong>其实就是收集数据、处理数据、可视化展示，再进行数据分析进行报警处理。</strong> 但其珍贵之处在于提供了一整套可行的解决方案，并且形成了一整个生态，能够极大地降低我们的研发成本。</p><p><img src="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/blog/16027237924160.jpg" alt="image-20220611213501419"></p><h2 id="Prometheus-的特点"><a href="#Prometheus-的特点" class="headerlink" title="Prometheus 的特点"></a>Prometheus 的特点</h2><ul><li> 易于管理</li></ul><p>➢ Prometheus 核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。</p><p>➢ Prometheus 基于 Pull 模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建我们的监控系统。</p><p>➢ 对于一些复杂的情况，还可以使用 Prometheus 服务发现(Service Discovery)的能力动态管理监控目标。</p><ul><li> 监控服务的内部运行状态</li></ul><p>Prometheus 鼓励用户监控服务的内部状态，基于Prometheus 丰富的 Client 库，用户可以轻松的在应用程序中添加对Prometheus 的支持，从而让用户可以获取服务和应用内部真正的运行状态。</p><ul><li> 强大的数据模型<img src="https://img-blog.csdnimg.cn/img_convert/ee4a62dba7a397c8881efda80a601b8b.png" alt="image-20220611213501420"></li></ul><p>所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中（TSDB，Time Series DB）。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http_request_status&#123;</span><br><span class="line">    code=&#x27;200&#x27;,</span><br><span class="line">    content_path=&#x27;/api/path&#x27;,</span><br><span class="line">    environment=&#x27;produment&#x27;</span><br><span class="line">&#125; =&gt;</span><br><span class="line">[value1@timestamp1,value2@timestamp2...]</span><br><span class="line"></span><br><span class="line">http_request_status&#123; # 指标名称</span><br><span class="line">    code=&#x27;200&#x27;, # 维度的标签</span><br><span class="line">    content_path=&#x27;/api/path2&#x27;,</span><br><span class="line">    environment=&#x27;produment&#x27;</span><br><span class="line">&#125; =&gt;</span><br><span class="line">[value1@timestamp1,value2@timestamp2...] # 存储的样本值</span><br></pre></td></tr></table></figure><p>每一条时间序列由**指标名称(Metrics Name)以及一组标签(Labels)**唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。</p><p>每一条时间序列由**指标名称(Metrics Name)以及一组标签(Labels)**唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。</p><p>➢ http_request_status：指标名称(Metrics Name)</p><p>➢ {code=‘200’,content_path=’/api/path’,environment=‘produment’}：表示维度的标签，基于这些 Labels 我们可以方便地对监控数据进行聚合，过滤，裁剪。</p><p>➢ [value1@timestamp1,value2@timestamp2…]：按照时间的先后顺序存储的样本值。</p><p>一个指标对应多个时序。（cpu的每个核心都是一个时序）</p><p>cpu使用率是个综合信息，如包含了用户空间使用率、内核空间使用率、切换使用率</p><p>指标是数据库， 每个表的字段是通过标签定义的</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7df8a3057cdcc9a2f16e8ad0f9874f81.png" alt="image-20220611213501421"></p><p>Job是Mysql主从复制进程，target是每个mysql</p><p>1.1.4 强大的查询语言 PromQL<br>Prometheus 内置了一个强大的数据查询语言 PromQL。 通过 PromQL 可以实现对监控数据的查询、聚合。同时 PromQL 也被应用于数据可视化(如 Grafana)以及告警当中。</p><p>通过PromQL 可以轻松回答类似于以下问题：</p><p>➢ 在过去一段时间中 95%应用延迟时间的分布范围？</p><p>➢ 预测在 4 小时后，磁盘空间占用大致会是什么情况？</p><p>➢ CPU 占用率前 5 位的服务有哪些？(过滤)</p><p>1.1.5 高效<br>对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而Prometheus 可以高效地处理这些数据，对于单一Prometheus Server 实例而言它可以处理：</p><p>➢ 数以百万的监控指标</p><p>➢ 每秒处理数十万的数据点</p><p>1.1.6 可扩展<br>可以在每个数据中心、每个团队运行独立的Prometheus Sevrer。Prometheus 对于联邦集群的支持，可以让多个 Prometheus 实例产生一个逻辑集群，当单实例 Prometheus Server 处理的任务量过大时，通过使用功能分区(sharding)+联邦集群(federation)可以对其进行扩展。</p><p>1.1.7 易于集成<br>使用Prometheus 可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持：Java，JMX，Python，Go，Ruby，.Net，Node.js 等等语言的客户端 SDK，基于这些 SDK 可以快速让应用程序纳入到 Prometheus 的监控当中，或者开发自己的监控数据收集程序。</p><p>同时这些客户端收集的监控数据，不仅仅支持 Prometheus，还能支持 Graphite 这些其他的监控工具。</p><p>同时Prometheus 还支持与其他的监控系统进行集成：Graphite，Statsd，Collected， Scollector， muini， Nagios 等。 Prometheus 社区还提供了大量第三方实现的监控数据采集支持：JMX，CloudWatch，EC2，MySQL，PostgresSQL，Haskell，Bash，SNMP， Consul，Haproxy，Mesos，Bind，CouchDB，Django，Memcached，RabbitMQ，Redis，RethinkDB，Rsyslog 等等。</p><p>1.1.8 可视化<br>➢ Prometheus Server 中自带的 Prometheus UI，可以方便地直接对数据进行查询，并且支持直接以图形化的形式展示数据。同时 Prometheus 还提供了一个独立的基于Ruby On Rails 的 Dashboard 解决方案 Promdash。</p><p>➢ 最新的 Grafana 可视化工具也已经提供了完整的Prometheus 支持，基于 Grafana 可以创建更加精美的监控图标。</p><p>➢ 基于Prometheus 提供的API 还可以实现自己的监控可视化UI。</p><p>1.1.9 开放性<br>通常来说当我们需要监控一个应用程序时，一般需要该应用程序提供对相应监控系统协议的支持，因此应用程序会与所选择的监控系统进行绑定。为了减少这种绑定所带来的限制，对于决策者而言要么你就直接在应用中集成该监控系统的支持，要么就在外部创建单独的服务来适配不同的监控系统。</p><p>而对于 Prometheus 来说，使用 Prometheus 的 client library 的输出格式不止支持Prometheus 的格式化数据，也可以输出支持其它监控系统的格式化数据，比如 Graphite。因此你甚至可以在不使用Prometheus 的情况下，采用 Prometheus 的 client library 来让你的应用程序支持监控数据采集。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/2022/05/18/Elasticsearch/"/>
      <url>/2022/05/18/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch-Windows"><a href="#Elasticsearch-Windows" class="headerlink" title="Elasticsearch(Windows)"></a>Elasticsearch(Windows)</h1><p>Elasticsearch(ES)是一个分布式全文搜索引擎。</p><p>ES客户端9200，服务端9300</p><h2 id="部分问题"><a href="#部分问题" class="headerlink" title="部分问题"></a>部分问题</h2><p>ES默认使用它自带的jdk版本，需要在环境变量中配置一下</p><p>ES8.0版本以上默认开启了ssl认证。修改elasticsearch.yml配置文件,将****xpack.security.enabled****设置为false</p><p>可能也需要修改network.host，改成自己的ip地址</p><h1 id="ES的简单使用"><a href="#ES的简单使用" class="headerlink" title="ES的简单使用"></a>ES的简单使用</h1><ul><li><p>GET请求   <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D">http://localhost:9200/索引名</a>    <strong>查询索引</strong></p></li><li><p>PUT请求   <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D">http://localhost:9200/索引名</a>    <strong>添加索引</strong></p></li><li><p>DELETE请求   <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D">http://localhost:9200/索引名</a>    <strong>删除索引</strong></p></li><li><p>添加索引时指定规则，在请求体中以JSON格式编写：</p><p>{</p><p>  “mappings”:{</p><p>​    “properties”:{</p><p>​      “id”:{</p><p>​        “type”:”keyword”</p><p>​      },</p><p>​      “name”:{</p><p>​        “type”:”text”,</p><p>​        “analyzer”:”ik_max_word”,</p><p>​        “copy_to”:”all”  }   }  }}</p></li><li><p>POST请求 <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_doc">http://localhost:9200/索引名/_doc</a>  <strong>创建文档，系统自动生成id</strong></p></li><li><p>POST请求 <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_doc/1">http://localhost:9200/索引名/_doc/1</a>  <strong>创建文档，指定id</strong></p></li><li><p>POST请求 <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_create/1">http://localhost:9200/索引名/_create/1</a>  <strong>创建文档，指定id</strong></p></li><li><p>创建文档时添加文档信息，在请求体中以JSON格式编写</p></li><li><p>GET请求　<a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_doc/1">http://localhost:9200/索引名/_doc/1</a>    <strong>查询指定id文档</strong></p></li><li><p>GET请求　<a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_search">http://localhost:9200/索引名/_search</a>    <strong>查询全部文档</strong></p></li><li><p>GET请求　<a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_search?q=%E5%B1%9E%E6%80%A7%E5%90%8D:value">http://localhost:9200/索引名/_search?q=属性名:value</a>  <strong>条件查询文档</strong></p></li><li><p>DELETE请求   <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_doc/1">http://localhost:9200/索引名/_doc/1</a>    <strong>删除指定id文档</strong></p></li><li><p>PUT请求　<a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_doc/1">http://localhost:9200/索引名/_doc/1</a>    <strong>修改指定id文档,在请求体写信息(全覆盖)</strong></p></li><li><p>POST请求　<a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D/_update/1">http://localhost:9200/索引名/_update/1</a>    <strong>部分修改指定id文档</strong>:</p><p>{</p><p>​         “doc”:{</p><p>​                “属性名”:value </p><p>​       }</p><p>}</p></li></ul><h1 id="Spring-Boot-整合ES"><a href="#Spring-Boot-整合ES" class="headerlink" title="Spring Boot 整合ES"></a>Spring Boot 整合ES</h1><p><strong>低版本整合</strong></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    uris: http://localhost:9200</span><br></pre></td></tr></table></figure><p>注入操作对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ElasticsearchRestTemplate est;</span><br></pre></td></tr></table></figure><p><strong>高版本整合</strong></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpHost</span> <span class="variable">host</span> <span class="operator">=</span> HttpHost.create(<span class="string">&quot;http://localhost:9200&quot;</span>);</span><br><span class="line"><span class="type">RestClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RestClient.builder(host);</span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(builder);</span><br><span class="line"><span class="comment">//客户端操作</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;dls&quot;</span>);</span><br><span class="line"><span class="comment">//获取操作索引的客户端对象，调用创建索引操作</span></span><br><span class="line">client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"><span class="comment">//关闭客户端</span></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>utils</title>
      <link href="/2022/05/12/utils/"/>
      <url>/2022/05/12/utils/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Security</title>
      <link href="/2022/05/09/Spring-Security/"/>
      <url>/2022/05/09/Spring-Security/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Security 是Spring家族中的一个安全管理框架。 </p><p>一般Web应用都需要进行<strong>认证</strong>和<strong>授权</strong>。</p><ul><li><p><strong>认证(authentication)：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p></li><li><p><strong>授权(authorization)：经过验证后判断当前用户是否有权限进行某个操作</strong></p></li></ul><p>而认证和授权也是Spring Security作为安全框架的核心功能</p><h1 id="1-快速使用"><a href="#1-快速使用" class="headerlink" title="1.快速使用"></a>1.快速使用</h1><p>添加依赖：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">&lt;/dependency&gt;</span></span><br><span class="line"><span class="code">&lt;dependency&gt;</span></span><br><span class="line"><span class="code">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-认证"><a href="#2-认证" class="headerlink" title="2.认证"></a>2.认证</h1><h2 id="2-1登录校验流程"><a href="#2-1登录校验流程" class="headerlink" title="2.1登录校验流程"></a>2.1登录校验流程</h2><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220510094605059.png" alt="image-20220510094605059"></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>Json web token (JWT)，是一个String字符串，由3部分组成，中间用点隔开。</p><p>令牌组成：</p><ol><li>标头（Header）</li><li>有效载荷（Payload）</li><li>签名（Signature）</li></ol><p>jwt格式：head.payload.singurater 如：xxxxx.yyyy.zzzz</p><p>Header：有令牌的类型和所使用的签名算法，如HMAC、SHA256、RSA；使用Base64编码组成；（Base64是一种编码，不是一种加密过程，可以被翻译成原来的样子）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;alg&quot; : &quot;HS256&quot;,</span><br><span class="line">&quot;type&quot; : &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Payload ：有效负载，包含声明；声明是有关实体（通常是用户）和其他数据的声明，不放用户敏感的信息，如密码。同样使用Base64编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;sub&quot; : &quot;123&quot;,</span><br><span class="line">&quot;name&quot; : &quot;John Do&quot;,</span><br><span class="line">&quot;admin&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signature ：前面两部分都使用Base64进行编码，前端可以解开知道里面的信息。Signature需要使用编码后的header和payload<br>加上我们提供的一个密钥，使用header中指定的签名算法(HS256)进行签名。签名的作用是保证JWT没有被篡改过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret);</span><br></pre></td></tr></table></figure><p><strong>签名目的：</strong>签名的过程实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</p><p>信息安全问题：Base64是一种编码，是可逆的，适合传递一些非敏感信息；JWT中不应该在负载中加入敏感的数据。如传输用户的ID被知道也是安全的，如密码不能放在JWT中；JWT常用于设计用户认证、授权系统、web的单点登录。</p><h2 id="2-2原理"><a href="#2-2原理" class="headerlink" title="2.2原理"></a>2.2原理</h2><p>SpringSecurity的原理其实就是一个<strong>过滤器链</strong>，内部包含了提供各种功能的过滤器。</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220510204158992.png" alt="image-20220510204158992"></p><p>图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p><p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p><p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p><p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p><p>​    我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220510204339774.png" alt="image-20220510204339774"></p><p>Spring Security的认证流程：</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220510204451222.png" alt="image-20220510204451222"></p><p>概念速查:</p><p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p><p>AuthenticationManager接口：定义了认证Authentication的方法 </p><p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p><p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p><h3 id="2-3-使用思路"><a href="#2-3-使用思路" class="headerlink" title="2.3 使用思路"></a>2.3 使用思路</h3><p>认证：前端发送登录信息</p><p>​    ①自定义登录接口  </p><p>​                调用ProviderManager的方法进行认证，如果认证通过生成jwt</p><p>​                <strong>然后用userid作为key，用户信息作为value存入redis中</strong></p><p>​    ②自定义UserDetailsService </p><p>​                在这个实现类中去查询数据库</p><p>校验：</p><p>​    前端携带token发起请求</p><p>​    ①定义Jwt认证过滤器</p><p>​                获取token</p><p>​                解析token获取其中的userid</p><p>​                从redis中获取用户信息</p><p>​                存入SecurityContextHolder</p><p>​     ②其他过滤器/资源从SecurityContextHolder中获取当前请求的用户信息</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>①添加依赖</p><pre><code>    &lt;!--redis依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--fastjson依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.33&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--jwt依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;        &lt;version&gt;0.9.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>② 添加Redis相关配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JavaType;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.type.TypeFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="comment">/*Redis使用FastJson序列化*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonRedisSerializer</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">RedisSerializer</span>&lt;T&gt;</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">   &#123;</span><br><span class="line">       ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FastJsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">super</span>();</span><br><span class="line">       <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (bytes == <span class="literal">null</span> || bytes.length &lt;= <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> JSON.parseObject(str, clazz);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">protected</span> JavaType <span class="title function_">getJavaType</span><span class="params">(Class&lt;?&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TypeFactory.defaultInstance().constructType(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">    </span><br><span class="line">        <span class="type">FastJsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastJsonRedisSerializer</span>(Object.class);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line">    </span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 响应类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line">   <span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseResult</span>&lt;T&gt; &#123;</span><br><span class="line">      <span class="keyword">private</span> Integer code;</span><br><span class="line">      <span class="keyword">private</span> String msg;</span><br><span class="line">      <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.code = code;</span><br><span class="line">       <span class="built_in">this</span>.msg = msg;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, T data)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.code = code;</span><br><span class="line">       <span class="built_in">this</span>.data = data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> code;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.code = code;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> msg;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.msg = msg;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.data = data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg, T data)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.code = code;</span><br><span class="line">       <span class="built_in">this</span>.msg = msg;</span><br><span class="line">       <span class="built_in">this</span>.data = data;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>④工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* JWT工具类*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">   <span class="comment">//有效期为</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">JWT_TTL</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000L</span>;<span class="comment">// 60 * 60 *1000  一个小时</span></span><br><span class="line">   <span class="comment">//设置秘钥明文</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JWT_KEY</span> <span class="operator">=</span> <span class="string">&quot;zzw&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUUID</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> token;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成jtw</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">      <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, <span class="literal">null</span>, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">      <span class="keyword">return</span> builder.compact();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成jtw</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ttlMillis token超时时间</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">      <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">      <span class="keyword">return</span> builder.compact();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> JwtBuilder <span class="title function_">getJwtBuilder</span><span class="params">(String subject, Long ttlMillis, String uuid)</span> &#123;</span><br><span class="line">       <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">       <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">       <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line">       <span class="keyword">if</span>(ttlMillis==<span class="literal">null</span>)&#123;</span><br><span class="line">           ttlMillis=JwtUtil.JWT_TTL;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">       <span class="type">Date</span> <span class="variable">expDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">       <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">               .setId(uuid)              <span class="comment">//唯一的ID</span></span><br><span class="line">               .setSubject(subject)   <span class="comment">// 主题  可以是JSON数据</span></span><br><span class="line">               .setIssuer(<span class="string">&quot;zzw&quot;</span>)     <span class="comment">// 签发者</span></span><br><span class="line">               .setIssuedAt(now)      <span class="comment">// 签发时间</span></span><br><span class="line">               .signWith(signatureAlgorithm, secretKey) <span class="comment">//使用HS256对称加密算法签名, 第二个参数为秘钥</span></span><br><span class="line">               .setExpiration(expDate);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建token</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ttlMillis</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String id, String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">      <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, id);<span class="comment">// 设置过期时间</span></span><br><span class="line">      <span class="keyword">return</span> builder.compact();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;</span>;</span><br><span class="line">       <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> parseJWT(token);</span><br><span class="line">       System.out.println(claims);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成加密后的秘钥 secretKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title function_">generalKey</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);</span><br><span class="line">      <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">      <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">              .setSigningKey(secretKey)</span><br><span class="line">              .parseClaimsJws(jwt)</span><br><span class="line">              .getBody();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit 时间颗粒度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value, <span class="keyword">final</span> Integer timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">return</span> operation.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除单个对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除集合对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection 多个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> Collection collection)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(collection);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存List数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList 待缓存的List数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">long</span> <span class="title function_">setCacheList</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> List&lt;T&gt; dataList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForList().rightPushAll(key, dataList);</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="number">0</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的list对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getCacheList</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSet 缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存数据的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; BoundSetOperations&lt;String, T&gt; <span class="title function_">setCacheSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Set&lt;T&gt; dataSet)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);</span><br><span class="line">        Iterator&lt;T&gt; it = dataSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            setOperation.add(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setOperation;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">getCacheSet</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMap</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Map&lt;String, T&gt; dataMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Map&lt;String, T&gt; <span class="title function_">getCacheMap</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往Hash中存入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey, <span class="keyword">final</span> T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hKey, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Hash中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash中的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();</span><br><span class="line">        <span class="keyword">return</span> opsForHash.get(key, hKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Hash中的数据 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hkey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hkey)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line">        hashOperations.delete(key, hkey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多个Hash中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKeys Hash键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getMultiCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Collection&lt;Object&gt; hKeys)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, hKeys);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 字符串前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">keys</span><span class="params">(<span class="keyword">final</span> String pattern)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串渲染到客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 渲染对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 待渲染的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">renderString</span><span class="params">(HttpServletResponse response, String string)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-2-密码加密存储"><a href="#2-3-3-2-密码加密存储" class="headerlink" title="2.3.3.2 密码加密存储"></a>2.3.3.2 密码加密存储</h3><p>​    实际项目中我们不会把密码明文存储在数据库中。</p><p>​    默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。    </p><p>​    我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p><p>​    我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p><p>​    我们可以定义一个Spring Security的配置类，Spring Security要求这个配置类要继承WebSecurityConfigurerAdapter。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   @Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-3-登陆接口"><a href="#2-3-3-3-登陆接口" class="headerlink" title="2.3.3.3 登陆接口"></a>2.3.3.3 登陆接口</h3><p>​    接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。</p><p>​    在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在<strong>SecurityConfig</strong>中配置把AuthenticationManager注入容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Override</span><br><span class="line">public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span><br><span class="line">    return super.authenticationManagerBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。</p><p>在Spring Security的配置类<strong>SecurityConfig</strong>中加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-4-认证过滤器"><a href="#2-3-3-4-认证过滤器" class="headerlink" title="2.3.3.4 认证过滤器"></a>2.3.3.4 认证过滤器</h3><p>​    我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。</p><p>​    使用userid去redis中获取对应的LoginUser对象。</p><p>​    然后封装Authentication对象存入SecurityContextHolder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//获取token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析token</span></span><br><span class="line">    String userid;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">        userid = claims.getSubject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从redis中获取用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span> + userid;</span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> redisCache.getCacheObject(redisKey);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(loginUser))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存入SecurityContextHolder</span></span><br><span class="line">    <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">    <span class="comment">//放行</span></span><br><span class="line">    filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>SecurityConfig</strong>中重写<strong>configure</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把token校验过滤器添加到过滤器链中</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-5-退出登陆"><a href="#2-3-3-5-退出登陆" class="headerlink" title="2.3.3.5 退出登陆"></a>2.3.3.5 退出登陆</h3><p>​    我们只需要定义一个接口，然后获取SecurityContextHolder中的认证信息(拿到userid)，删除redis中对应的数据即可。注意不用在SecurityContextHolder删除，因为退出登录是一个单独的请求，后面还有其他过滤器，把redis中的userid删掉后它已经获取不到用户信息被拦截了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> loginUser.getUser().getId();</span><br><span class="line">    redisCache.deleteObject(<span class="string">&quot;login:&quot;</span>+userid);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-授权"><a href="#3-授权" class="headerlink" title="3. 授权"></a>3. 授权</h2><h3 id="3-0-权限系统的作用"><a href="#3-0-权限系统的作用" class="headerlink" title="3.0 权限系统的作用"></a>3.0 权限系统的作用</h3><p>​    例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。</p><p>​    总结起来就是<strong>不同的用户可以使用不同的功能</strong>。这就是权限系统要去实现的效果。</p><p>​    我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。</p><p>​    所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。</p><h3 id="3-2-授权实现"><a href="#3-2-授权实现" class="headerlink" title="3.2 授权实现"></a>3.2 授权实现</h3><h4 id="3-2-1-限制访问资源所需权限"><a href="#3-2-1-限制访问资源所需权限" class="headerlink" title="3.2.1 限制访问资源所需权限"></a>3.2.1 限制访问资源所需权限</h4><p>​    SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。</p><p>​    但是要使用它我们需要先开启相关配置。在<strong>SecurityConfig</strong>中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br></pre></td></tr></table></figure><p>然后就可以使用对应的注解。@PreAuthorize</p><p>在要设置的方法上 <code>@PreAuthorize(&quot;hasAuthority(&#39;test&#39;)&quot;)</code></p><p>括号内的test就是访问所需的权限，以字符串形式标识</p><h4 id="3-2-2-封装权限信息"><a href="#3-2-2-封装权限信息" class="headerlink" title="3.2.2 封装权限信息"></a>3.2.2 封装权限信息</h4><p>​    我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。</p><p>​    我们先直接把权限信息写死封装到UserDetails中进行测试。</p><p>​    我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//存储权限信息</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user,List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">    <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储SpringSecurity所需要的权限信息的集合</span></span><br><span class="line"><span class="meta">@JSONField(serialize = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span>  Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">    <span class="keyword">if</span>(authorities!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中</span></span><br><span class="line">    authorities = permissions.stream().</span><br><span class="line">            map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> authorities;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//只要能获取到permissions，就能调用getAuthorities获取权限信息</span></span><br></pre></td></tr></table></figure><p>修改UserDetailsServiceImpl，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。</p><h4 id="3-2-3-从数据库查询权限信息"><a href="#3-2-3-从数据库查询权限信息" class="headerlink" title="3.2.3 从数据库查询权限信息"></a>3.2.3 从数据库查询权限信息</h4><h5 id="3-2-3-1-RBAC权限模型"><a href="#3-2-3-1-RBAC权限模型" class="headerlink" title="3.2.3.1 RBAC权限模型"></a>3.2.3.1 RBAC权限模型</h5><p>​    RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。</p><p><img src="/2022/05/09/Spring-Security/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220517113651486.png" alt="image-20220517113651486"></p><p>然后我们可以在<strong>UserDetailsServiceImpl</strong>中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。注意<strong>JwtAuthenticationTokenFilter</strong>也要修改。</p><h2 id="4-自定义失败处理"><a href="#4-自定义失败处理" class="headerlink" title="4. 自定义失败处理"></a>4. 自定义失败处理</h2><p>​    我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p><p>​    在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p><p>​    如果是认证过程中出现的异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p><p>​    如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p><p>​    所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。</p><p>自定义实现类实现方法后需要配置给SpringSecurity</p><p>在<strong>SecurityConfig</strong>中的configure方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).</span><br><span class="line">               accessDeniedHandler(accessDeniedHandler);</span><br></pre></td></tr></table></figure><h2 id="5-跨域"><a href="#5-跨域" class="headerlink" title="5. 跨域"></a>5. 跨域</h2><p>​    浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 </p><p>​    前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p><p>​    所以我们就要处理一下，让前端能进行跨域请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">①先对SpringBoot配置，运行跨域请求</span><br><span class="line">@Configuration</span><br><span class="line"></span><br><span class="line">public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line">@Override</span><br><span class="line">public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">  // 设置允许跨域的路径</span><br><span class="line">    registry.addMapping(&quot;/**&quot;)</span><br><span class="line">            // 设置允许跨域请求的域名</span><br><span class="line">            .allowedOriginPatterns(&quot;*&quot;)</span><br><span class="line">            // 是否允许cookie</span><br><span class="line">            .allowCredentials(true)</span><br><span class="line">            // 设置允许的请求方式</span><br><span class="line">            .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)</span><br><span class="line">            // 设置允许的header属性</span><br><span class="line">            .allowedHeaders(&quot;*&quot;)</span><br><span class="line">            // 跨域允许时间</span><br><span class="line">            .maxAge(3600);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②开启SpringSecurity的跨域访问</p><p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。在SecurityConfig中：</p><p> <code>//允许跨域   http.cors();</code></p><h1 id="其他权限校验方法"><a href="#其他权限校验方法" class="headerlink" title="其他权限校验方法"></a>其他权限校验方法</h1><p>SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p><p>hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据是否在权限列表中。</p><p>​    hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p><p>​    hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><p>​    hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><h2 id="自定义权限校验方法"><a href="#自定义权限校验方法" class="headerlink" title="自定义权限校验方法"></a>自定义权限校验方法</h2><p>我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGExpressionRoot</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAuthority</span><span class="params">(String authority)</span>&#123;</span><br><span class="line">    <span class="comment">//获取当前用户的权限</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">    List&lt;String&gt; permissions = loginUser.getPermissions();</span><br><span class="line">    <span class="comment">//判断用户权限集合中是否存在authority</span></span><br><span class="line">    <span class="keyword">return</span> permissions.contains(authority);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在SPEL表达式中使用 @ex相当于获取容器中bean的名字为ex的对象。然后再调用这个对象的hasAuthority方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于配置的权限控制"><a href="#基于配置的权限控制" class="headerlink" title="基于配置的权限控制"></a>基于配置的权限控制</h3><p>​    我们也可以在配置类中使用使用配置的方式对资源进行权限控制。</p><p>在SecurityConfig类中的configure方法中：</p><p>   <img src="/2022/05/09/Spring-Security/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220517162112943.png" alt="image-20220517162112943"></p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>​    CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p><p>​    <a href="https://blog.csdn.net/freeking101/article/details/86537087">https://blog.csdn.net/freeking101/article/details/86537087</a></p><p>​    SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p><p>​    我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring、SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log</title>
      <link href="/2022/04/26/Log/"/>
      <url>/2022/04/26/Log/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Slf4j来输出日志"><a href="#使用Slf4j来输出日志" class="headerlink" title="使用Slf4j来输出日志"></a>使用Slf4j来输出日志</h1><p>导入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>如果是springboot 就不需要在pom添加依赖，它默认集成了log4j2和logback框架。</p><h3 id="logback-xml放在resource目录下，其基本结构如下："><a href="#logback-xml放在resource目录下，其基本结构如下：" class="headerlink" title="logback.xml放在resource目录下，其基本结构如下："></a>logback.xml放在resource目录下，其基本结构如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!--configuration根节点--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender &gt;</span><br><span class="line">        &lt;!--其他配置省略--&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger&gt;</span><br><span class="line">        &lt;!--其他配置省略--&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;!--其他配置省略--&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p><strong>appender:</strong> 主要负责日志信息的输出(打印)工作<br><strong>logger:</strong> 主要负责日志信息的的接受，过滤以及委托appender进行输出工作<code>root为其父类</code><br><strong>root:</strong> 主要负责日志信息的的接受，过滤以及委托appender进行输出工作<code>logger为其子类</code></p><p>&lt;**cnfiguration**&gt;根节点的属性配置<br><strong>scan</strong>: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。<br><strong>scanPeriod</strong>: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。<br><strong>debug</strong>: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p><p>在配置文件中，我们可以用 ${} 的方式来使用，将变量引入到其他节点中去。如果有多处使用相同的内容，便可使用属性变量的方式进行统一，减少很多不必要的代码；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;pattern&quot; value=&quot;asd&quot; &gt;&lt;/property&gt;</span><br></pre></td></tr></table></figure><p> 在后面${name}引用</p><p>&lt;<strong>appender&gt;子标签的属性配置</strong><br><strong>name(<code>必要</code>)：</strong>为<code>&lt;appender&gt;</code>节点的名称<br><strong>class(<code>必要</code>)：</strong>为<code>&lt;appender&gt;</code>的全限定类名，也就是日志输出目的地的处理类</p><p>&lt;**logger**&gt;子节点<br>详细解释：<br>用来设置某一个包或具体的某一个类的日志打印级别、以及指定appender。logger仅有一个name属性，一个可选的level和一个可选的addtivity属性。<br>可以包含零个或多个appender-ref元素，标识这个appender将会添加到这个loger</p><p><strong>name</strong>(必要): 用来指定受此loger约束的某一个包或者具体的某一个类。<br><strong>level</strong>（可选）: 用来设置门限级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前loger将会继承上级的级别。<br><strong>addtivity</strong>: 是否向上级loger传递打印信息。默认是true。同一样，可以包含零个或多个元素，标识这个appender将会添加到这个loger。</p><p>&lt;**root**&gt;子标签，它也是loger元素，但是它是根loger,是所有loger的上级。只有一个level属性，因为name已经被命名为”root”,且已经是最上级了。</p><p>详细介绍appender 标签的内部结构<br>1.关于控制台的appender（ConsoleAppender）</p> <appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender">        <!--name:主要用来区分不同的appender         class:       指定输出（打印）日志信息的全限定类名         ch.qos.logback.core.ConsoleAppender  //对应日志输出到控制台的appender         -->     <layout class="ch.qos.logback.classic.PatternLayout">      <!--     Layout:  负责把事件转换成字符串，格式化的日志信息的输出(这种方式已经不被官方推荐)     class     :全限定类名          -->            <pattern>         <!--          %d表示日期,格式为：yyyy-MM-dd HH:mm:ss.SSS ;        %msg:日志消息;        %n:换行-->                %d-%msg%n            </pattern>        </layout>    </appender><p>当使用默认的logback.xml时，输出格式如下<br>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n<br>%d{HH: mm:ss.SSS}——日志输出时间 %thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用 %-5level——日志级别，并且使用5个字符靠左对齐 %logger{36}——日志输出者的名字 %msg——日志消息 %n——平台的换行符</p><p>2.把日志添加到文件的appender（FileAppender）</p><p><file>：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。<br><append>：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。<br><encoder>：对记录事件进行格式化。<br><prudent>：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。<br>例：</prudent></encoder></append></file></p><appender name="FILE" class="ch.qos.logback.core.FileAppender"> 　　　　<file>testFile.log</file> 　　　　<append>true</append> 　　　　<encoder> 　　　　　　<pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern> 　　　　</encoder> 　　</appender> <p>3.滚动记录文件（RollingFileAppender）{额外注解：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。}</p><appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">    <file>e:/log.out</file>    <!--日志存储位置-->    <append>true</append>     <prudent>false</prudent>    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">    <!--时间滚动策略，每天生成一个.log文件-->        <fileNamePattern>testLog-%d{yyyy-MM-dd}.log</fileNamePattern>        <!--.log文件名称设置,例：testLog-2019-7-30.log-->        <maxHistory>30</maxHistory>        <!--设置最大保存时间-->    </rollingPolicy>    <!--下面设置输出格式-->    <encoder>        <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>    </encoder></appender><p><rollingPolicy>滚动策略<br>日志文件的滚动策略，与RollingFileAppender搭配使用，当日志文件发生变动时决定RollingFileAppender的行为；</rollingPolicy></p><p>class属性取值：TimeBasedRollingPolicy、FixedWindowRollingPolicy；</p><p>第一种：TimeBasedRollingPolicy<br>ch.qos.logback.core.rolling.TimeBasedRollingPolicy表示根据时间制定日志文件的滚动策略；</p><p>例：</p><rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">    <fileNamePattern>testLog-%d{yyyy-MM-dd}.log</fileNamePattern>    <!--可以直接指定文件存储位置     例：D:\Documents\Desktop\日志文件夹\info.%d{yyyy-MM-dd}.log   -->    <maxHistory>30</maxHistory>    <!--保存30天--></rollingPolicy><p>第二种：FixedWindowRollingPolicy<br>ch.qos.logback.core.rolling.FixedWindowRollingPolicy表示如果日志文件大小超过指定范围时，会根据文件名拆分成多个文件；</p><p>例：</p><rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">    <fileNamePattern>tests.%i.log.zip</fileNamePattern>    <!--%i即是下标值，下面两个配置指定下标范围1~3-->   <minIndex>1</minIndex>    <maxIndex>3</maxIndex>  </rollingPolicy>  <triggeringPolicy>日志触发器策略，常用的是日志的大小的控制，当日志达到对应的大小的时候，就会触发。生成新的日志文件。日志大小的控制配合rollingPlicy使用的时候，不同的rollingPolicy会有所不同。<p>ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy表示根据日志文件大小，超过制定大小会触发日志滚动；<br>例</p><appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"> 　　　　　　<file>test.log</file> <p>　　　　　　<rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"><br>　　　　　　　　　　<fileNamePattern>tests.%i.log.zip</fileNamePattern><br>　　　　　　　　　　<minIndex>1</minIndex><br>　　　　　　　　　　<maxIndex>3</maxIndex><br>　　　　　　</rollingPolicy> </p><p>　　　　　　<triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"><br>　　　　　　　　　　<maxFileSize>5MB</maxFileSize><br>　　　　　　</triggeringPolicy><br>　　　　　　<encoder><br>　　　　　　　　　<pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern><br>　　　　　　</encoder><br>　　　</p></appender> <p></p><p>4.异步记录日志<br>补充材料：</p><p>异步记录日志，内部通过使用缓存的方式来实现异步打印，将日志打印事件event放入缓存中。具体数据结构为BlockingQueue；</p><p>例子：<br><appender name="FILE" class="ch.qos.logback.core.FileAppender"><br>    <file>e:/log.out</file><br>    <append>true</append><br>    <prudent>false</prudent><br>    <encoder><br>        <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern><br>    </encoder><br></appender><br><appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender"><br>    <discardingThreshold>0</discardingThreshold><br>    <queueSize>512</queueSize><br>    <appender-ref ref="FILE"><br></appender-ref></appender>  </p><p>子节点&lt;**queueSize**&gt;：指的是BlockingQueue的队列容量大小，默认为256个；<br>子节点&lt;**discardingThreshold**&gt;：如果BlockingQueue中还剩余20%的容量，那么程序会丢弃TRACE、DEBUG和INFO级别的日志打印事件event，只保留WARN和ERROR级别的。为了保留所有的日志打印事件，可以将该值设置为0。</p><p>5.&lt;**encoder**&gt;</p><p>日志格式化节点，负责格式化日志信息。只负责了两件事情，第一负责将日志信息转换成字节数组，第二将字节数组写到输出流当中去；</p><p>%logger：表示输出logger名称，后面跟一个{0}表示：只输出logger最右边点符号之后的字符串；例如：com.jiaboyan.test —&gt; test;</p><p>%d{HH:mm:ss.SSS}：表示格式化日期输出，14:06:49.812；</p><p>%line:输出执行日志请求的行号。</p><p>%thread：表示产生日志的线程名；</p><p>%level:输出日志级别；</p><p>%method:输出执行日志请求的方法名;</p><p>%class:输出日志打印类的全限定名，后面跟{0}表示，含义为全限定类名最右边点符号之后的字符串。例如：com.jiaboyan.test —&gt; test;</p><p>%-4relative含义：符号减号“-”是左对齐 标志，接着是可选的最小宽度 修饰符，用十进制数表示。relative是输出从程序启动到创建日志记录的时间，单位是毫秒;</p><p>%msg：表示应用程序提供需要打印的日志信息；</p><p>%n：表示换行符；</p><h1 id="Spring-Boot之logging"><a href="#Spring-Boot之logging" class="headerlink" title="Spring Boot之logging"></a>Spring Boot之logging</h1><p>SpringBoot内部使用Commons Logging作为日志记录门面，但是当使用SpringBoot场景启动器时默认是使用的<a href="https://blog.csdn.net/xintonghanchuang/article/details/91348467">SLF4J</a>+<a href="https://blog.csdn.net/xintonghanchuang/article/details/91348257">Logback</a>进行日志记录。上文就是手写，这里是Spring代劳，我们也可以修改其源码自定义效果</p><p>spring-boot-starter-logging，但SpringBoot中所有starter都继承了spring-boot-starters，所以我们创建一个SpringBoot项目就自带logging，可以直接使用了。</p><p>直接在配置文件配置日志相关的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info //配置根目录日志输出级别</span><br><span class="line">  file:</span><br><span class="line">    name: service.log   //指定生成的日志文件名</span><br><span class="line">  logback:</span><br><span class="line">    rollingpolicy:</span><br><span class="line">      file-name-pattern: service.%d.%i.log</span><br><span class="line">      max-file-size: 4KB</span><br></pre></td></tr></table></figure></triggeringPolicy>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>essays</title>
      <link href="/2022/04/22/essays/"/>
      <url>/2022/04/22/essays/</url>
      
        <content type="html"><![CDATA[<h1 id="随便写写的知识点"><a href="#随便写写的知识点" class="headerlink" title="随便写写的知识点"></a>随便写写的知识点</h1><h1 id="MySQL数据自增ID不连续"><a href="#MySQL数据自增ID不连续" class="headerlink" title="MySQL数据自增ID不连续"></a>MySQL数据自增ID不连续</h1><p>在多次增删后，可能会出现数据库自增id不连续的情况</p><p><code>alter table tablename AUTO_INCREMENT=1;</code></p><p>在每次插入数据之后，修正那个AUTO_INCREMENT值。再次插入数据时，会从你设置的值开始再数一遍，插入的id就是1；而是表中id最大值+1，如果此表数据量很多的话，这样执行起来会很慢。</p><p><code>truncate table tb_name;</code></p><p>直接删除表，再重新创建一个新表，保留分区，分区定义（.par）文件不受影响，下次插入数据时auto_increment字段会自动从0开始。 <strong>注意表的数据会清空！</strong></p><p>delete语句只删除数据而不重置AUTO_INCREMENT</p><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>注：swagger是一种API规范，springfox是其规范的一种实现，要注意Spring boot版本和swagger-spring-boot-starter版本的兼容</p><h3 id="1-引入swagger依赖"><a href="#1-引入swagger依赖" class="headerlink" title="1.引入swagger依赖"></a>1.引入swagger依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.spring4all&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><code>swagger-spring-boot-starter</code> 是一款建立在<code>swagger</code>基础之上的工具包，利用SpringBoot自动装配的特性，简化了传统<code>swagger</code>的繁琐配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.spring4all&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-编写配置类"><a href="#2-编写配置类" class="headerlink" title="2.编写配置类"></a>2.编写配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">api</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()   .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.包名.controller&quot;</span>)) </span><br><span class="line">            <span class="comment">//扫描生成API的Controller包名，将会为该包下的controller生成相关文档</span></span><br><span class="line">                .paths(PathSelectors.any())  <span class="comment">//允许您根据路径映射定义应包含哪个控制器的方法。我们现在包括所有这些，但您可以使用正则表达式等限制它。</span></span><br><span class="line">                                             <span class="comment">// 上面的代码.paths(PathSelectors.any())是代表匹配所有URL</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;系統API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;众所周知的API文档&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;zzw&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-编写api注解"><a href="#3-编写api注解" class="headerlink" title="3.编写api注解"></a>3.编写api注解</h3><p>加在类上<br> **@ApiModel(tags = “说明该类的作用，可以在UI界面上看到的注解”)**用于类 ；表示对类进行说明，用于参数用实体类接收 这个类是swagger的资源<br> 加在方法上<br> **@ApiModel(value = “方法描述”,notes = “提示内容”)**用于类 ；表示对类进行说明，用于参数用实体类接收()   表示一个http请求的操作<br> **@ApiModel(name = “参数名”,value = “参数说明”,required = true)**用于类 ；表示对类进行说明，用于参数用实体类接收</p><p>当有多个参数时用@ApiImplicitParams</p><p>当参数是个对象时，参数前加入，@RequestBody，这样才能将对象的属性给到swagger</p><p>**@ApiModel(value=”对象名”，description=”描述”)**用于类 ；表示对类进行说明，用于参数用实体类接收</p><p>访问路径：应用地址+端口+swagger-ui.html 例如<a href="http://localhost:8800/swagger-ui.html">http://localhost:8800/swagger-ui.html</a></p><h3 id="4-部分报错"><a href="#4-部分报错" class="headerlink" title="4.部分报错"></a>4.部分报错</h3><p>报错：<strong>Failed to start bean ‘documentationPluginsBootstrapper’</strong></p><p>springboot的版本更新，导致的swagger2的异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    pathch:</span><br><span class="line">      matching-strategy: ant_path_matcher</span><br></pre></td></tr></table></figure><p>springboot2.6.0中将SpringMVC 默认路径匹配策略从AntPathMatcher 更改为PathPatternParser，导致出错，解决办法是切换回原先的AntPathMatcher</p><h1 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run()和start()的区别"></a>run()和start()的区别</h1><p>start()方法：</p><p>通过该方法启动线程的同时也创建了一个线程，真正实现了多线程。无需等待run()方法中的代码执行完毕，就可以接着执行下面的代码。此时start()的这个线程处于就绪状态，当得到CPU的时间片后就会执行其中的run()方法。这个run()方法包含了要执行的这个线程的内容，run()方法运行结束，此线程也就终止了。</p><p>run()方法：</p><p>通过run方法启动线程其实就是调用一个类中的方法，当作普通的方法的方式调用。并没有创建一个线程，程序中依旧只有一个主线程，必须等到run()方法里面的代码执行完毕，才会继续执行下面的代码，这样就没有达到写线程的目的。<br>而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行,被一个线程反复调用，也可以被单独调用</p><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>start() 可以启动一个新线程，run()不能</li><li>start()不能被重复调用，run()可以</li><li>start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。</li><li>start() 实现了多线程，run()没有实现多线程。</li></ul><h1 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a><em>Serializable</em>接口</h1><p>它一个对象序列化的<strong>接口</strong>，<strong>一个类只有实现了Serializable接口，它的对象才是可序列化的</strong>。因此如果要序列化某些类的对象，这些类就必须实现<a href="https://so.csdn.net/so/search?q=Serializable&spm=1001.2101.3001.7020">Serializable</a>接口。它只是一个<strong>标识</strong>，是一个空接口</p><p>什么是序列化：</p><ul><li>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</li></ul><p>为什么要序列化：</p><ul><li>把对象转换为字节序列的过程称为对象的序列化</li><li>把字节序列恢复为对象的过程称为对象的反序列化</li></ul><p>什么情况下需要序列化：</p><ul><li>当你想把的内存中的对象写入到硬盘的时候。</li><li>当你想用套接字(socket)在网络上传送对象的时候。</li><li>当你想通过RMI(远程调用,说白了就是在一台服务器运行的代码里面调用只存在于另一台服务器上某个对象的方法)传输对象的时候。</li></ul><h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><p> <a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p><strong>mysql 8 驱动不同 com.mysql.cj.jsbc.Driver、需要增加时区的配置</strong></p><p><strong>物理删除 ：从数据库中直接移出</strong></p><p><strong>逻辑删除：在数据库中没有被移出，而是通过一个变量来让他失效！deleted=0 ==&gt;deleted =1(失效)</strong></p><p>这里记录一下快速使用MP，导入依赖就不说了。</p><ul><li><p>Mapper类要继承BaseMapper&lt;实体类&gt; ,里面有一些常用的增删改查</p></li><li><p>service类继承IService&lt;实体类&gt;</p></li><li><p>serviceImpl类继承ServiceImpl&lt;对应的Mapper类,实体类&gt; implements 对应的service类</p></li><li><pre><code>#配置日志mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #仅控制台输出的日志#指定mapper路径mybatis-plus: mapper-locations: com/mp/mapper/* configuration:   #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射   #mp默认开启   map-underscore-to-camel-case: true   og-impl: org.apache.ibatis.logging.stdout.StdOutImpl<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 当表名与实体类名不一致时，可以在实体类上加入**@TableName(value=&quot;&quot;)**声明, **@TableId**声明属性为表中的主键（不然可能识别不到主键，出现null错误），同时要注意命名规范，当命名方式出现冲突时，可以用**@TableField(value=&quot;&quot;)**指定属性对应非主键的字段名</span><br><span class="line"></span><br><span class="line">- 自定义方法：**在Mapper类中使用@Select、@Insert等注解，自定义sql语句**</span><br><span class="line"></span><br><span class="line">- ![image-20220517012502187](C:\Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220517012502187.png)</span><br><span class="line"></span><br><span class="line">### 分页查询</span><br><span class="line"></span><br><span class="line">配置拦截器组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>//Spring boot方式@EnableTransactionManagement@Configuration@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)public class MybatisPlusConfig &#123;  @Bean  public PaginationInterceptor paginationInterceptor() &#123;      PaginationInterceptor paginationInterceptor = new PaginationInterceptor();      // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false      // paginationInterceptor.setOverflow(false);      // 设置最大单页限制数量，默认 500 条，-1 不受限制      // paginationInterceptor.setLimit(500);      // 开启 count 的 join 优化,只针对部分 left join      paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));      return paginationInterceptor;  &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">测试</span><br><span class="line"></span><br></pre></td></tr></table></figure>//测试分页查询@Testpulic void testPage()&#123;  // 参数一：当前页  // 参数二：页面大小  // 使用了分页插件之后，所有的分页操作也变得简单了  Page&lt;User&gt; page =new Page&lt;&gt;(2,5);  userMapper.selectPage(page,null);  page.getRecords().forEach(System.out::println);  //获取总数  page.getTotal();&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 性能分析插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>@Bean  @Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)// 设置 dev test 环境开启  public PerformanceInterceptor performanceInterceptor() &#123;      PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();      performanceInterceptor.setMaxTime(100);// ms 设置sql执行的最大时间，如果超过就停止      performanceInterceptor.setFormat(true);      return new PerformanceInterceptor();  &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># java.lang.ClassNotFoundException: javax.xml.bind.DatatypeConverter</span><br><span class="line"></span><br><span class="line">Jdk高版本中会出现这样的问题</span><br><span class="line"></span><br><span class="line">JAXB API是java EE 的API，因此在java SE 9.0 中不再包含这个 Jar 包。</span><br><span class="line">java 9 中引入了模块的概念，默认情况下，Java SE中将不再包含java EE 的Jar包而在 java 6/7 / 8 时关于这个API 都是捆绑在一起的</span><br><span class="line"></span><br><span class="line">结论：jar包中缺少这一依赖-javax.xml.bind.api</span><br><span class="line"></span><br><span class="line">解决方法：添加依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;dependency&gt;  &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;  &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;  &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2022/04/14/Linux/"/>
      <url>/2022/04/14/Linux/</url>
      
        <content type="html"><![CDATA[<p>🐧画得不够形象，莫得灵魂</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/u=1090189516,820941418&fm=253&fmt=auto&app=138&f=JPEG.webp"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>regularExpressions</title>
      <link href="/2022/04/13/regularExpressions/"/>
      <url>/2022/04/13/regularExpressions/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h1><ul><li>验证密码长度：\d{6,18}$</li><li>验证密码不能使用纯字母或数字：[A-Za-z]+[0-9]</li><li>验证8到16位、必须有小写字母+大写字母+特殊字符+数字组成的密码：(?=^.{8,16}$)(?=.<em>\d)(?=.<em>\W+)(?=.</em>[a-z])(?=.</em>[A-Z])(?!.<em>\n).</em>$</li><li>验证由数字、26个英文字母或下划线组成的字符串：^\w+$</li><li>验证邮编：[1-9]\d{5}</li><li>验证电话号码：(\d{3,4}-)?\d{6,8}$</li><li>验证手机号：[1][3-5]\d{9}$</li><li>验证身份证号：(\d{18}$)|(^\d{15}$)</li><li>验证一年的12个月份：(0?[[1-9]|1[0-2]]$</li><li>验证一个月的31天：((0?[1-9])|((1|2)[0-9])|30|31)$</li><li>验证日期（yyyy-mm-dd）：^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</li><li>验证日期(年-月-日)：(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))</li><li>验证日期(月/日/年) ：[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})</li><li>验证时间(小时:分钟, 24小时制)：((1|0?)[0-9]|2[0-3]):([0-5][0-9])</li><li>验证数字输入： [0-9]*$</li><li>验证非零的正整数：+?[1-9][0-9]*$</li><li>验证非零的负整数：-[1-9][0-9]*$</li><li>验证小数：(-?\d+)(.\d+)?</li><li>验证两位小数：[0-9]+.[0-9]{2}$</li><li>验证金额（精确到2位小数）：^[0-9]+(.[0-9]{2})?$</li><li>验证大写字母：[A-Z]+$</li><li>验证小写字母：[a-z]+$</li><li>验证字母：[A-Za-z]+$</li><li>验证中文汉字：^[\u4e00-\u9fa5]{0,}$</li><li>验证E-mail：[\w!#$%&amp;’<em>+/=?^_<code>&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_</code>{|}~-]+)</em>@(?:<a href="?:%5B%5Cw-%5D*%5B%5Cw%5D">\w</a>?\.)+<a href="?:%5B%5Cw-%5D*%5B%5Cw%5D">\w</a>?</li><li>验证IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</li><li>验证URL：http(s)?://([\w-]+.)+[\w-]+(/[\w- ./?%&amp;=]*)?</li><li>验证QQ号码：[1-9]\d{4,}</li><li>匹配HTML标签：&lt;\/?\w+((\s+\w+(\s*=\s*(?:”.<em>?”|’.*?’|[\^’”&gt;\s]+))?)+\s</em>|\s*)\/?&gt;</li><li>查找CSS属性：^\s*[a-zA-Z\-]+\s*[:]{1}\s[a-zA-Z0-9\s.#]+[;]{1}</li><li>提取页面超链接：(\s*(?!.<em>\brel=)[^&gt;]</em>)(href=”https?:\/\/)((?!(?:(?:www\.)?’.implode(‘|(?:www\.)?’, $follow_list).’))[^”]+)”((?!.<em>\brel=)[^&gt;]</em>)(?:[^&gt;]*)&gt;</li><li>提取网页图片：\&lt; <em>[img][^\&gt;]</em>[src] *= <em>[\“\‘]{0,1}([^\“\‘\ &gt;]</em>)</li><li>提取URL链接：^(f|ht){1}(tp|tps):\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&amp;=]*)?</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装docker</title>
      <link href="/2022/04/08/Centos7InstallDocker/"/>
      <url>/2022/04/08/Centos7InstallDocker/</url>
      
        <content type="html"><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/04/08/docker/"/>
      <url>/2022/04/08/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是Docker，用它来干嘛，为什么要用它等基础介绍转载自阮一峰大佬的文章<a href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></p><p>docker的安装参考 <a href="https://deimos.magi-verse.com/2022/04/08/Centos7InstallDocker/">Centos7下安装docker</a></p><h1 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  # 启动docker服务</span><br><span class="line">systemctl stop docker  # 停止docker服务</span><br><span class="line">systemctl restart docker  # 重启docker服务</span><br></pre></td></tr></table></figure><p>镜像名称:[repository]:[tag]     e.g: mysql:5.7</p><p>镜像相关命令： e.g: docker pull redis ，docker rmi redis</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220411190306000.png" alt="image-20220411190306000"></p><p>容器相关命令（基本都是望文生义）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker run  容器名  #创建并运行一个容器</span><br><span class="line">&gt; docker pause 容器名/unpause 容器名</span><br><span class="line">&gt; docker stop  容器名/start 容器名</span><br><span class="line">&gt; docker rm 容器名</span><br><span class="line">&gt; docker logs 容器名 -f(跟踪日志输出)</span><br><span class="line">&gt; docker ps #查看所有运行中的容器及状态 -a(查看全部容器)</span><br><span class="line">&gt; docker exec #进入容器执行命令</span><br></pre></td></tr></table></figure><h1 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h1><p><code>&gt; docker run --name 容器名 -p 端口映射 -d     镜像名</code></p><p>-d：后台运行</p><p>-p：端口映射  80:80 宿主端口：容器端口</p><p>进入容器<code>docker exec -it 容器名 bash</code></p><p>-it：给当前进入的容器创建一个标准输入、输出终端、允许我们与容器交互</p><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p><p>但是在容器内修改文件是不推荐的</p><p><strong>退出容器且不关闭容器: Ctrl + p + q</strong> </p><p>补充：运行mysql容器时要在命令加上-e MYSQL_ROOT_PASSWORD=你的密码 否则运行失败</p><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>数据卷volume是一个虚拟目录，指向宿主机文件系统中的某个目录</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220413141158915.png" alt="image-20220413141158915"></p><p><code>docker volume command</code></p><p>常用数据卷命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker volume create  #创建一个volume</span><br><span class="line">&gt; docker volume inspect #显示一个或多个volume信息</span><br><span class="line">&gt; docker volume ls   #列出所有volume</span><br><span class="line">&gt; docker volume prune #删除未使用的volume</span><br><span class="line">&gt; docker volume rm #删除一个或多个指定的volume</span><br><span class="line">&gt; docker inspect 数据卷名  #获取容器/镜像的元数据</span><br></pre></td></tr></table></figure><h3 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h3><p>在创建容器时可以通过-v参数来将数据卷挂载到容器中的某个目录(数据卷会自动创建)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker run --name 容器名 -v 宿主机文件(数据卷): 容器内文件</span><br><span class="line">&gt; docker run --name mn -v html:/usr/share/nginx/html </span><br></pre></td></tr></table></figure><p>当容器挂载了数据卷，即可在容器外修改容器内容(它们是双向绑定)</p><p>在宿主机数据卷的目录默认是 var/lib/docker/volumes/xxx/…/   也可以自己指定</p><p>想知道容器内的文件位置可以到dockerhub官方文档查找</p><p><strong>docker volume inspect 容器名 #查看数据卷位置</strong></p><p><strong>在cd到该目录 vim修改文件</strong></p><h1 id="Dockerfile自定义镜像"><a href="#Dockerfile自定义镜像" class="headerlink" title="Dockerfile自定义镜像"></a>Dockerfile自定义镜像</h1><ul><li>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成</li></ul><p>镜像是分层结构，包括基础镜像BaseImage、入口Entrypint、其他依赖和安装程序</p><p>基础镜像可以是操作系统、也可以是别人制作好的镜像</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220416160456909.png" alt="image-20220416160456909"></p><p>其他语法，文档：<a href="https://blog.csdn.net/qq_42896653/article/details/122010894">Dockerfile 参考文档中文版</a></p><p>dockerfile文件示例：</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220503223603507.png" alt="image-20220503223603507"></p><p><strong>将一个Java项目构建成镜像：</strong></p><ul><li><p>新建一个工作目录，然后在里面新建Dockerfile文件</p></li><li><p>将Java项目打包成jar包并放到目录里</p></li><li><p>编写Dockerfile文件(Java项目一般需要指定jdk版本)</p></li><li><p>docker build -t 构建好的镜像名 Dockerfile所在的目录 </p><p>e.g: docker build -t javaweb:1.0 .            #注意这个.表示所需的Dockerfile所在的目录</p></li><li><p>使用docker run创建容器并运行</p></li></ul><h1 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h1><ul><li><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p></li><li><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行，形式如下图(两种方式)：</p></li><li><p>DockerCompose的安装参考 <a href="https://deimos.magi-verse.com/2022/04/08/Centos7InstallDocker/">Centos7下安装docker</a></p></li><li><p>Compose 使用的三个步骤：</p><p>使用 Dockerfile 定义应用程序的环境。</p><p>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</p><p>最后，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p> 命令来启动并运行整个应用程序。</p></li></ul><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220419144135241.png" alt="image-20220419144135241"></p><p>这里要求版本最好和装好的DockerCompose版本对应 <strong>查看版本 docker-compose version</strong></p><p><strong>dockercompose里的服务之间都可以用服务名访问</strong></p><p>注意：</p><p>mysql挂载数据卷时指定的路径 $PWD 和 . 的区别</p><p>WARNING: The PWD variable is not set. Defaulting to a blank string.</p><h3 id><a href="#" class="headerlink" title></a></h3><p><strong>试着将之前写的微服务项目用DockerCompose部署</strong></p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220422135137678.png" alt="image-20220422135137678"></p><p>每个微服务有它的jar包和Dockerfile，而docker-compose.yml则会帮我们自动构建镜像</p><p>微服务对应的dockerfile：</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220503224728913.png" alt="image-20220503224728913"></p><p>docker-compose.yml示例：</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220422135418552.png" alt="image-20220422135418552"></p><h1 id="微服务部署可能会出现的问题"><a href="#微服务部署可能会出现的问题" class="headerlink" title="微服务部署可能会出现的问题"></a>微服务部署可能会出现的问题</h1><p>在各个微服务的配置文件中，地址都是localhost的形式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service-url:</span><br><span class="line">  defaultZone: http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><p>在 IDEA 或者主机上编译部署后项目也能够正常运行，可是一旦放入 Docker 中，很奇怪的事情就发生了：当要指定地址的时候总是失败。</p><p>其实问题产生的原因很简单，因为 bridge 是 Docker 默认的网络模式，换句话说，我一个 host 上的各个 container 从 docker 获取的 IP 都是不一样的（在主机编译部署后大家都是 localhost，但是在 docker 里面情况就不一样了）。</p><p>所以再使用 <a href="http://localhost:8761/eureka/%E8%BF%99%E4%B8%AA%E5%80%BC%E8%82%AF%E5%AE%9A%E6%98%AF%E6%89%BE%E4%B8%8D%E5%88%B0">http://localhost:8761/eureka/这个值肯定是找不到</a> Eureka 的地址。</p><p>怎么办呢，可以利用 docker 的主机名来解决。</p><p>我们只需要为 Eureka 所在的 container 配置一个主机名即可，比如我们配置为 eureka-server</p><p>即用Eureka 服务器所在的服务名代指</p><p>那么再将其他的微服务的配置进行如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service-url:</span><br><span class="line">  defaultZone: http://EUREKA-SERVER:8761/eureka/</span><br></pre></td></tr></table></figure><h1 id="使用docker-compose部署nginx"><a href="#使用docker-compose部署nginx" class="headerlink" title="使用docker-compose部署nginx"></a>使用docker-compose部署nginx</h1><h3 id="step1：创建一个nginx的工作目录"><a href="#step1：创建一个nginx的工作目录" class="headerlink" title="step1：创建一个nginx的工作目录"></a>step1：创建一个nginx的工作目录</h3><p>　　暂定目录为 nginxpath</p><h3 id="step2：创建一个默认的nginx容器"><a href="#step2：创建一个默认的nginx容器" class="headerlink" title="step2：创建一个默认的nginx容器"></a>step2：创建一个默认的nginx容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker run --name nginx-demo -d nginx</span><br></pre></td></tr></table></figure><h3 id="step3：复制相关的配置文件"><a href="#step3：复制相关的配置文件" class="headerlink" title="step3：复制相关的配置文件"></a>step3：复制相关的配置文件</h3><p>docker cp 命令用于在容器和本地文件系统之间复制文件/文件夹(双向)</p><p>两个路径之间用空格隔开表示</p><p>将nginx-demo容器的配置文件拷贝到当前目录        注意 . 表示当前目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd /nginxpath</span><br><span class="line">&gt; docker cp nginx-demo:/etc/nginx/nginx.conf .</span><br><span class="line">&gt; docker cp nginx-demo:/etc/nginx/conf.d/default.conf .</span><br><span class="line">&gt; docker cp nginx-demo:/usr/share/nginx/html .</span><br></pre></td></tr></table></figure><p>目录结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginxpath</span><br><span class="line">├── conf.d</span><br><span class="line">│   ├── default.conf</span><br><span class="line">├── html</span><br><span class="line">│   ├── 50x.html</span><br><span class="line">│   └── index.html</span><br><span class="line">└── nginx.conf</span><br></pre></td></tr></table></figure><h3 id="step4：编写docker-compose-yml文件"><a href="#step4：编写docker-compose-yml文件" class="headerlink" title="step4：编写docker-compose.yml文件"></a>step4：编写docker-compose.yml文件</h3><p>为了方便管理，我们新建一个文件夹conf用来存放nginx.conf文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1 version: &quot;3.0&quot;</span><br><span class="line"> 2 </span><br><span class="line"> 3 services:</span><br><span class="line"> 4   ngnix:                                          #服务名称，名称可自定义</span><br><span class="line"> 5     container_name: nginx-compose              #容器名称，可自定义</span><br><span class="line"> 6     image: nginx                                   # 镜像名称</span><br><span class="line"> 7     restart: always</span><br><span class="line"> 8     ports:                                     # 容器和服务器对应的端口映射，每次新增一个站点之后一定要在这里把对应的端口映射加上，不然肯定会404</span><br><span class="line"> 9       - 80:80</span><br><span class="line">10       - 8080:8080</span><br><span class="line">11       - 8081:8081</span><br><span class="line">12       - 8082:8082</span><br><span class="line">13     privileged: true</span><br><span class="line">14     volumes:</span><br><span class="line">15       - /home/install/softs/04.nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">16       - /home/install/softs/04.nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span><br><span class="line">17       - /home/install/softs/04.nginx/logs:/var/log/nginx</span><br><span class="line">18       - /home/install/softs/04.nginx/html:/usr/share/nginx/html</span><br><span class="line">19       - /etc/letsencrypt:/etc/letsencrypt</span><br><span class="line">20       - /etc/localtime:/etc/localtime</span><br></pre></td></tr></table></figure><p>目录结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nginxpath</span><br><span class="line">├── conf.d #配置文件目录</span><br><span class="line">│ ├── default.conf #默认的配置文件</span><br><span class="line">├── html #静态文件资源</span><br><span class="line">│ ├── 50x.html #错误页面</span><br><span class="line">│ └── index.html #首页</span><br><span class="line">├── conf #自定义配置文件目录</span><br><span class="line">│ └── nginx.conf #自定义配置文件</span><br><span class="line">└── docker-compose.yml #docker-compose配置文件</span><br></pre></td></tr></table></figure><h3 id="step5：运行docker-compose查看结果"><a href="#step5：运行docker-compose查看结果" class="headerlink" title="step5：运行docker-compose查看结果"></a>step5：运行docker-compose查看结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="end：删除-nginx-demo镜像"><a href="#end：删除-nginx-demo镜像" class="headerlink" title="end：删除 nginx-demo镜像"></a>end：删除 nginx-demo镜像</h3><h1 id="Dokcer镜像仓库"><a href="#Dokcer镜像仓库" class="headerlink" title="Dokcer镜像仓库"></a>Dokcer镜像仓库</h1><p>镜像仓库(Docker Registry)：</p><ul><li>公共仓库：我们接触过的dockerhub就是一个公共的镜像仓库，国内的有网易云镜像服务、DaoCloud、阿里云镜像服务等</li><li>用户还可以在本地搭建私有Docker Registry。</li></ul><h2 id="简化版镜像仓库"><a href="#简化版镜像仓库" class="headerlink" title="简化版镜像仓库"></a>简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷r egistry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="带有图形化界面版本"><a href="#带有图形化界面版本" class="headerlink" title="带有图形化界面版本"></a>带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure><h2 id="配置Docker信任地址"><a href="#配置Docker信任地址" class="headerlink" title="配置Docker信任地址"></a>配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置json格式：</p><p>注意ip地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="推送、拉取镜像"><a href="#推送、拉取镜像" class="headerlink" title="推送、拉取镜像"></a>推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/04/06/Git/"/>
      <url>/2022/04/06/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git最简单的使用流程"><a href="#Git最简单的使用流程" class="headerlink" title="Git最简单的使用流程"></a>Git最简单的使用流程</h1><p>安装和部署在各种编译软件上的过程就不再赘述了，百度都有相应的教程，这里默认安装好了git。</p><p>在当前文件夹右键打开Git Bash：</p><p>git init 命令用于在目录中创建新的 Git 仓库</p><p>复制自己的仓库只需 git clone <a href="https://github.com/dullandmeanless/dullandmeanless.github.io.git">https://github.com/dullandmeanless/dullandmeanless.github.io.git</a></p><p>复制别人的仓库先fork到自己的仓库中，修改完再git request向仓库原主人发请求</p><p>git add <filename></filename></p><p>想要撤回本次add，可以git reset  head <filename> </filename></p><p>git commit -m <message></message></p><p>执行commit后，还没执行push时，想要撤销这次的commit，该怎么办？</p><p>解决方案： 使用命令：git reset –soft HEAD^ (–soft表示不删除工作空间的改动代码，–hard 删除工作空间的改动代码、^表示上一个版本，HEAD~2表示撤回上两个版本的commit)</p><p>另外一点，如果commit注释写错了，先要改一下注释，有其他方法也能实现，如：git commit –amend 这时候会进入vim编辑器，修改完成你要的注释后保存即可。</p><p>git push</p><h1 id="fork和clone的区别-fetch与pull的区别"><a href="#fork和clone的区别-fetch与pull的区别" class="headerlink" title="fork和clone的区别,fetch与pull的区别"></a>fork和clone的区别,fetch与pull的区别</h1><p>fork：在github页面，点击fork按钮。将别人的仓库复制一份到自己的仓库。</p><p>clone：将github中的仓库克隆到自己本地电脑中</p><p>问题：pull request的作用</p><p>比如在仓库的主人（A）没有把我们添加为项目合作者的前提下，我们将A的某个仓库名为“a”的仓库clone到自己的电脑中，在自己的电脑进行修改，但是我们会发现我们没办法通过push将代码贡献到B中。</p><p>所以要想将你的代码贡献到B中，我们应该：</p><ol><li>在A的仓库中fork项目a （此时我们自己的github就有一个一模一样的仓库a，但是URL不同）</li><li>将我们修改的代码push到自己github中的仓库B中</li><li>pull request ，主人就会收到请求，并决定要不要接受你的代码</li><li>也可以可以申请为项目a的contributor，这样可以直接push</li></ol><p>(2) fork了别人的项目到自己的repository之后，别人的项目更新了，我们fork的项目怎么更新？</p><p>答：首先fetch网上的更新到自己的项目上，然后再判断、merge。这里就涉及了下一个问题，pull和fetch有啥区别。</p><p> （3）fetch+merge与pull效果一样。但是要多用fetch+merge，这样可以检查fetch下来的更新是否合适。pull直接包含了这两步操作，如果你觉得网上的更新没有问题，那直接pull也是可以的。</p><p> git revert 和 git reset的区别</p><ul><li>git revert 用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；</li><li>git reset 回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</li></ul><h1 id="如何撤销-Git-操作？"><a href="#如何撤销-Git-操作？" class="headerlink" title="如何撤销 Git 操作？"></a>如何撤销 Git 操作？</h1><p>转载自<a href="https://ruanyifeng.com/blog/2019/12/git-undo.html%EF%BC%8C%E5%9C%A8%E4%B8%8A%E7%BD%91%E5%AD%A6%E4%B9%A0Git%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%97%B6%EF%BC%8C%E5%B1%85%E7%84%B6%E5%8F%88%E6%89%BE%E5%88%B0%E4%BA%86%E9%98%AE%E4%B8%80%E5%B3%B0%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%BB%96%E5%86%99%E5%BE%97%E5%AE%9E%E5%9C%A8%E6%98%AF%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%EF%BC%8C%E6%88%91%E4%B8%AA%E4%BA%BA%E5%86%8D%E5%8E%BB%E6%80%BB%E7%BB%93%E8%BF%99%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C%E4%B9%9F%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8(%E6%9C%89%E5%88%A0%E6%94%B9)%EF%BC%9A">https://ruanyifeng.com/blog/2019/12/git-undo.html，在上网学习Git的相关知识时，居然又找到了阮一峰大佬的文章，由于他写得实在是浅显易懂，我个人再去总结这部分操作也没有意义，这里直接引用(有删改)：</a></p><h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#x27;xxx&#x27;                                       # 提交</span><br><span class="line">git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features/performance                         # 检出已存在的features/performance分支</span><br><span class="line">git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT                # 清理不必要的文件并优化本地存储库</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发</title>
      <link href="/2022/03/29/Multithreading/"/>
      <url>/2022/03/29/Multithreading/</url>
      
        <content type="html"><![CDATA[<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序的执行过程，是动态的、并发的、暂时的、</li><li>程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令、管理内存、管理IO的 </li><li>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程</li><li>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</li><li>进程是拥有资源的独立单位、进程是独立调度和分派的基本单位</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。线程是进程中的一个实体，是系统独立调度和分派的基本单位</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器（这里感觉要学了计算机组成原理之后会更有感觉吧！）</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li> 调度</li></ul><p>  线程调度快，需要空间小。</p><p>   进程因拥有资源，调度时因负担过重而缓慢。</p><ul><li><p>并发性</p><p> 在引入线程的操作系统中，不仅进程之间可以并发执行，一个进程中的多个线程之间亦可并发执行。</p></li><li><p>拥有资源</p><p>  进程是资源的拥有者</p></li><li><p>系统开销</p><p> 进程切换的开销远远大于线程切换的开销，线程的 切换省去了资源的回收。</p></li></ul><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做<strong>任务调度器</strong>，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是<strong>同时运行</strong>的（<strong>逻辑</strong>上同时发生） 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）</p><p><img src="https://gitee.com/gu_chun_bo/picture/raw/master/image/20200305194534-433138.png" alt="1583408729416"></p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行（<strong>物理</strong>上同时发生）。</p><p><img src="https://gitee.com/gu_chun_bo/picture/raw/master/image/20200305194655-483025.png" alt="1583408812725"></p><h3 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h3><p>引用 Rob Pike 的一段描述：并发（concurrent）是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）</li></ul><h1 id="同步和异步的概念"><a href="#同步和异步的概念" class="headerlink" title="同步和异步的概念"></a>同步和异步的概念</h1><p>以调用方的角度讲，如果需要等待结果返回才能继续运行的话就是同步，如果不需要等待就是异步</p><h4 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h4><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。</p><h4 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h4><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><p>方法一，直接使用Thread：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法的参数是给线程指定名字，，推荐给线程起个名字</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="comment">// run 方法内实现了要执行的任务</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);&#125;&#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>方法二，使用 Runnable 配合 Thread</p><p>把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）Test2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);&#125;&#125;;</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>常用(匿名内部类)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                xx&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/03/28/Redis/"/>
      <url>/2022/03/28/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis是一款key-value存储结构的内存级NoSQL数据库"><a href="#Redis是一款key-value存储结构的内存级NoSQL数据库" class="headerlink" title="Redis是一款key-value存储结构的内存级NoSQL数据库"></a>Redis是一款key-value存储结构的内存级NoSQL数据库</h1><h2 id="windows版本"><a href="#windows版本" class="headerlink" title="windows版本"></a>windows版本</h2><p>在其安装目录中打开命令行启动服务端：<br><code>redis-server.exe redis.windows.conf</code></p><p>在新的命令窗口启动客户端：<code>redis-cli</code> 开始进行数据库操作</p><p>set name value        →       set name zzw</p><p>get name                     →          zzw</p><p>hset key field value      →       hset keya a1 zzw</p><p>hget key field               →        hget keya a1             →       zzw</p><p>redis没有查看当前是哪个数据库的命令，因为当你在哪个数据库的时候，会显示其的索引号。因为你客户端刚连接redis的时候，默认的是第一个数据库，也就是索引号为0，不显示。切换成其他的数据库，就会显示其对应的索引号了。</p><p>redis默认有16个数据库，在其配置文件redis.conf可以查看。</p><h2 id="Spring-Boot整合Redis"><a href="#Spring-Boot整合Redis" class="headerlink" title="Spring Boot整合Redis"></a>Spring Boot整合Redis</h2><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用时添加操作Redis接口对象 RedisTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="type">ValueOperations</span> <span class="variable">ops</span> <span class="operator">=</span> redisTemplate.opsForValue(); </span><br><span class="line">    ops.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;value&quot;</span>);       </span><br><span class="line">    ops.get(<span class="string">&quot;name&quot;</span>);                </span><br></pre></td></tr></table></figure><h3 id="在客户端操作redis是以字符串的形式"><a href="#在客户端操作redis是以字符串的形式" class="headerlink" title="在客户端操作redis是以字符串的形式"></a>在客户端操作redis是以字符串的形式</h3><h3 id="在SpringBoot中操作用RedisTemplate是以对象的形式"><a href="#在SpringBoot中操作用RedisTemplate是以对象的形式" class="headerlink" title="在SpringBoot中操作用RedisTemplate是以对象的形式"></a>在SpringBoot中操作用RedisTemplate是以对象的形式</h3><h3 id="要想保持一致-使用StringRedisTemplate接口对象-常用"><a href="#要想保持一致-使用StringRedisTemplate接口对象-常用" class="headerlink" title="要想保持一致 使用StringRedisTemplate接口对象(常用)"></a>要想保持一致 使用StringRedisTemplate接口对象(常用)</h3><h1 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h1><p>启动redis服务<br>在redis的src目录下执行命令：<br>./redis-server</p><p>启动redis客户端实例<br>在redis的src目录下执行命令：<br>./redis-cli</p><p>连接远程redis服务器：<br>redis-cli -h host -p port -a password</p><p>设置key-value<br>set key value</p><p>获取值<br>get key</p><p>删除<br>del key</p><p>判断key是否存在<br>exists key</p><p>设置10秒过期<br>expire key 10</p><p>设置10毫秒过期<br>pexpire key 10</p><p>删除过期时间<br>persist key</p><p>切换数据库<br>redis有16个数据库，默认使用0号数据库，切换数据库的命令为：<br>select index（index表示数据库编号）</p><p>清空当前选中的数据库<br>flushdb</p><p>清空所有数据库<br>flushall</p><p>查看当前数据库的所有key<br>keys *</p><p>查看字段类型<br>type key</p><h1 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h1><p><strong>jedis</strong>就是基于java语言的redis客户端，集成了redis的命令操作，提供了连接池管理。</p><p>redis-cli是redis官方提供的客户端，可以看作一个shell程序，它可以发送命令对redis进行操作。<br>对于jedis同理是使用java语言操作redis，双方都遵循redis提供的协议，按照协议开发对应的客户端。</p><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件中启用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: <span class="number">6379</span></span><br><span class="line">      client-type: jedis</span><br></pre></td></tr></table></figure><h3 id="与lettcus的区别"><a href="#与lettcus的区别" class="headerlink" title="与lettcus的区别"></a>与lettcus的区别</h3><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220329160216629.png" alt="image-20220329160216629"></p><p>jedis直连，本质是定义一个tcp连接，然后使用socket技术进行通信</p><p>jedis的简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.生成一个jedis对象，这个对象负责和指定Redis节点进行通信</span></span><br><span class="line">   <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;119.23.226.29&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">   <span class="comment">//带密码需要执行认证方法</span></span><br><span class="line">   <span class="comment">//jedis.auth(&quot;123456&quot;);</span></span><br><span class="line">   <span class="comment">//2.jedis执行set操作</span></span><br><span class="line">   jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">   <span class="comment">//3.jedis执行get操作，value=&quot;world&quot;</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb(Windows)</title>
      <link href="/2022/03/28/Mongodb/"/>
      <url>/2022/03/28/Mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="Mongodb是一个开源、高性能、无模式的文档型数据库"><a href="#Mongodb是一个开源、高性能、无模式的文档型数据库" class="headerlink" title="Mongodb是一个开源、高性能、无模式的文档型数据库"></a>Mongodb是一个开源、高性能、无模式的文档型数据库</h1><p>官方文档中文版：<a href="https://docs.mongoing.com/">https://docs.mongoing.com/</a></p><p>启动服务端在bin目录命令行输入：mongod –dbpath=..\data\db         指定存放位置</p><p>启动mongodb服务时需要先确定数据库文件存放的位置，否则系统不会自动创建，启动会不成功。</p><p>客户端启动： mogo –host=127.0.0.1 –port=27017     默认端口是27017</p><p>当注册到本地服务后就不用那么麻烦(会默认一直启动) 通过net start /stop 服务名 我这里是Mongodb 启动，即net start Mongodb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\mongodb\bin&gt;mongod --dbpath &quot;D:\mongodb\data\db&quot; --logpath &quot;D:\mongodb\data\log\mongodb.log&quot; --serviceName &quot;Mongodb&quot; --serviceDisplayName &quot;Mongodb&quot; --install</span><br></pre></td></tr></table></figure><p>可视化工具 <strong>Robo3T</strong></p><p>注意 mongod 和 mongo 的区别</p><p>　　前者是启用MongoDB进程，后者是对MongoDB进行连接操作</p><h1 id="Mongodb的基本使用"><a href="#Mongodb的基本使用" class="headerlink" title="Mongodb的基本使用"></a>Mongodb的基本使用</h1><p>官方文档：<a href="https://docs.mongoing.com/mongodb-crud-operations">https://docs.mongoing.com/mongodb-crud-operations</a></p><h3 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h3><ul><li><p>库<DataBase></DataBase></p><p>  mongodb中的库就类似于传统关系型<strong>数据库</strong>中库的概念，用来通过不同库隔离不同应用数据。 mongodb中可以建立多个数据库。每一个库都有自己的集合和权限，不同的数据库也放置在不同的文件中。默认的数据库为”test”，数据库存储在启动指定的data目录中。</p></li><li><p>集合<collection></collection></p><p>集合就是 MongoDB 文档组，类似于 RDBMS (关系数据库管理系统:Relational Database Management System)中的<strong>表</strong>的概念。<br>集合存在于数据库中，一个库中可以创建多个集合。每个集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p></li><li><p>文档<Document></Document></p><p>文档集合中一条条记录，是一组**键值(**key-value)对(即BSON)。MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是MongoDB非常突出的特点。</p></li><li><p>文档示例：{“name”:”zzw”,”site”:”<a href="https://deimos.magi-verse.com/&quot;%7D">https://deimos.magi-verse.com/&quot;}</a></p></li></ul><h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><p>创建数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> use 库名; <span class="operator">/</span><span class="operator">/</span>创建并使用，当库中没有数据时默认不显示这个库</span><br></pre></td></tr></table></figure><p>三个系统库:<br>admin: 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。<br>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合<br>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</p><p>删除数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在当前库中 <span class="operator">&gt;</span> db.dropDatabase();</span><br></pre></td></tr></table></figure><p>查看当前所在库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db;</span><br></pre></td></tr></table></figure><p>查看库中所有集合：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">show</span> collection<span class="operator">/</span>tables; </span><br></pre></td></tr></table></figure><p>创建集合：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.createCollection(&quot;集合名称&quot;,[options])</span><br><span class="line">options可以是以下参数：capped、size、max</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220506203451435.png" alt="image-20220506203451435"></p><p>删除集合：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.<span class="keyword">drop</span>();</span><br></pre></td></tr></table></figure><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.<span class="keyword">insert</span><span class="operator">/</span>save(&#123;&quot;name&quot;:&quot;springboot&quot;&#125;);</span><br><span class="line"><span class="keyword">insert</span>和save的区别：</span><br><span class="line"><span class="keyword">insert</span>在_id存在时 主键冲突 报错</span><br><span class="line">save在_id存在时 更新数据 即覆盖</span><br><span class="line">批处理时<span class="keyword">insert</span>可以一次性插入全部数据，效率高；save需要遍历整个数组，效率较低</span><br><span class="line"><span class="operator">&gt;</span> db.集合.<span class="keyword">insert</span>([&#123;&quot;name&quot;:&quot;springboot&quot;&#125;,&#123;&quot;name&quot;:&quot;springcloud&quot;&#125;]);</span><br></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find(); <span class="operator">/</span><span class="operator">/</span>查询全部</span><br><span class="line"><span class="operator">&gt;</span> db.集合.find().pretty(); <span class="operator">/</span><span class="operator">/</span>以格式化的方式显示</span><br><span class="line"><span class="operator">&gt;</span> db.集合.find(&#123;name:&quot;xxxx&quot;&#125;); <span class="operator">/</span><span class="operator">/</span>查询条件</span><br><span class="line"><span class="operator">&gt;</span> db.集合.find(&#123;数组:&#123;$size:<span class="number">3</span>&#125;&#125;); <span class="operator">/</span><span class="operator">/</span>按照数组长度查询</span><br></pre></td></tr></table></figure><ul><li>更多格式：</li></ul><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220505210511917.png" alt="image-20220505210511917"></p><ul><li><p>AND</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find(&#123;条件<span class="number">1</span>,条件<span class="number">2</span>&#125;); <span class="operator">/</span><span class="operator">/</span>相同字段做多次查询，只差最后一个条件</span><br></pre></td></tr></table></figure></li><li><p>OR</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find(&#123;$<span class="keyword">or</span>:[&#123;条件&#125;]&#125;);</span><br></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find().sort(&#123;字段:<span class="number">1</span>,字段<span class="number">2</span>:<span class="number">-1</span>&#125;); <span class="operator">/</span><span class="operator">/</span><span class="number">1</span>表示升序，<span class="number">-1</span>表示降序</span><br></pre></td></tr></table></figure></li><li><p>分页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find().<span class="keyword">skip</span>(起始条数).limit(<span class="keyword">rows</span>);</span><br></pre></td></tr></table></figure></li><li><p>模糊查询(类似mysql中的  % → / ) </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find(&#123;name:<span class="operator">/</span>张<span class="operator">/</span>&#125;); <span class="operator">/</span><span class="operator">/</span>注意没有双引号</span><br><span class="line">使用正则表达式可以近似实现模糊查询</span><br></pre></td></tr></table></figure></li><li><p>总条数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find().<span class="built_in">count</span>();</span><br><span class="line"><span class="operator">&gt;</span> db.集合.find(条件).<span class="built_in">count</span>(); <span class="operator">/</span><span class="operator">/</span>符合条件的总条数</span><br></pre></td></tr></table></figure></li><li><p>去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.<span class="keyword">distinct</span>(字段)</span><br><span class="line">将去重后的字段以数组形式返回</span><br></pre></td></tr></table></figure></li><li><p>指定返回字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.find(&#123;条件&#125;,&#123;字段:<span class="number">1</span>,字段:<span class="number">0</span>&#125;);</span><br><span class="line"><span class="number">1</span>表示返回，<span class="number">0</span>表示不返回，注意它们不能同时使用</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.remove(&#123;条件&#125;); </span><br><span class="line"><span class="operator">&gt;</span> db.集合.remove(&#123;&#125;);  <span class="operator">/</span><span class="operator">/</span>删除所有文档</span><br></pre></td></tr></table></figure><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.<span class="keyword">update</span>(&#123;name:&quot;要修改的&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;name:&quot;修改成&quot;&#125;&#125;);   <span class="operator">/</span><span class="operator">/</span>改符合条件的第一条</span><br><span class="line"><span class="operator">&gt;</span> db.集合.<span class="keyword">update</span>(&#123;name:&quot;要修改的&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;name:&quot;修改成&quot;&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;);   <span class="operator">/</span><span class="operator">/</span>改所有符合条件的</span><br><span class="line"><span class="operator">&gt;</span> db.集合.<span class="keyword">update</span>(&#123;name:&quot;要修改的&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;name:&quot;修改成&quot;&#125;&#125;,&#123;upsert:<span class="literal">true</span>&#125;);  <span class="operator">/</span><span class="operator">/</span>没有条件符合时插入该数据</span><br><span class="line"><span class="operator">&gt;</span> db.集合.updatemany</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220329163400255.png" alt="image-20220329163400255"></p><h2 id="type操作符"><a href="#type操作符" class="headerlink" title="$type操作符"></a>$type操作符</h2><p>$type操作符是基于BSON类型来检索集合中匹配的数据类型并返回</p><p><img src="/2022/03/28/Mongodb/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220505213920285.png" alt="image-20220505213920285"></p><p>在文档查询时可以用$type查询类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.集合.find(&#123;&quot;字段名&quot;:&#123;$type:2&#125;&#125;); //查询集合中字段名为String类型的数据</span><br><span class="line">&gt; db.集合.find(&#123;&quot;字段名&quot;:&#123;$type:&#x27;String&#x27;&#125;&#125;); //查询集合中字段名为String类型的数据</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引<index></index></h2><p>官方文档：<a href="https://docs.mongoing.com/indexes">https://docs.mongoing.com/indexes</a></p><p>索引是特殊的数据结构，索引存储在一个易于读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。</p><p>创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.集合.createIndex(&#123;字段,options&#125;)</span><br><span class="line">eg:<span class="operator">&gt;</span> db.集合.createIndex(&#123;&quot;title&quot;:<span class="number">1</span>,&quot;description&quot;:<span class="number">-1</span>&#125;) <span class="operator">/</span><span class="operator">/</span><span class="number">1</span>表示升序 <span class="number">-1</span>表示降序</span><br></pre></td></tr></table></figure><p>options可选</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220505235040987.png" alt="image-20220505235040987"></p><p>查看集合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.集合.getIndexes();  </span><br><span class="line">&gt; db.集合.totalIndexSize(); //查看集合所有大小</span><br><span class="line">&gt; db.集合.dropIndexes();  //删除集合所有索引</span><br><span class="line">&gt; db.集合.dropIndex(&quot;索引名称&quot;)</span><br></pre></td></tr></table></figure><p>复合索引：</p><p>mongodb中复合索引和传统关系型数据库一致都是左前缀原则</p><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询<aggregate></aggregate></h3><p>mongodb中聚合主要用于处理数据(平均值、求和)，并返回计算后数据结果。</p><p>db.集合名称.aggregate([{$group:{_id:key}}])</p><p>注意这个 <strong>_id</strong> 表示的是以哪个key作为分组的标识符</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220506001132469.png" alt="image-20220506001132469"></p><h1 id="Spring-Boot整合Mongodb"><a href="#Spring-Boot整合Mongodb" class="headerlink" title="Spring Boot整合Mongodb"></a>Spring Boot整合Mongodb</h1><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      uri: mongodb:<span class="comment">//localhost/test    指定数据库名</span></span><br><span class="line">      uri: mongodb:<span class="comment">//127.0.0.1:27017/test</span></span><br></pre></td></tr></table></figure><p>使用时添加操作mongodb的接口对象MongoTemplate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private MongoTemplate mt;</span><br><span class="line">//集合</span><br><span class="line">mt.createCollection();</span><br><span class="line">mt.dropCollection();</span><br></pre></td></tr></table></figure><p>Java中的对象可以作为文档被添加到mongodb中，不过要加注解约束</p><p><strong>————-注意接口对象怎么找集合名称—————</strong></p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220506002923753.png" alt="image-20220506002923753"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(&quot;user&quot;)</span></span><br><span class="line">User&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  Integer id;</span><br><span class="line">  <span class="meta">@Field(&quot;username&quot;)</span></span><br><span class="line">  String name;</span><br><span class="line">  Integer age;</span><br><span class="line">  <span class="meta">@Transient</span></span><br><span class="line">  Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Document(“user”)指明集合名称</p><p>@Id让成员变量id映射为文档中的_id唯一标识</p><p>@Field让成员变量name映射到文档中时是username</p><p>@Transient让成员变量birthday不会加入文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private MongoTemplate mt;</span><br><span class="line">User user = new User(2,&quot;zzw&quot;,&quot;21&quot;,new Date());</span><br><span class="line">mt.insert(user);</span><br></pre></td></tr></table></figure><p>添加多条文档：</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220506003957985.png" alt="image-20220506003957985"></p><ul><li><p>用接口对象MongoTemplate进行查询操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mt;</span><br><span class="line">mt.findAll(实体类.class);     <span class="comment">//查询全部</span></span><br><span class="line">mt.findAll(实体类.class,集合名称);     <span class="comment">//查询全部</span></span><br><span class="line">mt.findById(id,实体类.class); <span class="comment">//根据id查询</span></span><br><span class="line">mt.find(Query.query(Criteria.where(<span class="string">&quot;字段名&quot;</span>).is(<span class="string">&quot;查询条件&quot;</span>)).实体类.class); <span class="comment">//等值查询</span></span><br><span class="line"><span class="comment">// &gt;gt &lt;lt &gt;=gte &lt;=lte</span></span><br><span class="line">mt.find(Query.query(Criteria.where(<span class="string">&quot;字段名&quot;</span>).lt(<span class="string">&quot;查询条件&quot;</span>)).实体类.class);</span><br><span class="line"><span class="comment">// and查询</span></span><br><span class="line">mt.find(Query.query(Criteria.where(<span class="string">&quot;字段名&quot;</span>).is(<span class="string">&quot;查询条件&quot;</span>).and(<span class="string">&quot;字段名&quot;</span>).is(<span class="string">&quot;查询条件&quot;</span>)).实体类.class);</span><br><span class="line"> <span class="comment">// or查询</span></span><br><span class="line">要先创建Criteria对象</span><br><span class="line">Criteria criteria=<span class="keyword">new</span> <span class="title class_">Criteria</span>();</span><br><span class="line">Criteria.orOperator(</span><br><span class="line">       Criteria.where(<span class="string">&quot;字段名&quot;</span>).is(<span class="string">&quot;查询条件&quot;</span>),</span><br><span class="line">       Criteria.where(<span class="string">&quot;字段名&quot;</span>).is(<span class="string">&quot;查询条件&quot;</span>)</span><br><span class="line">);</span><br><span class="line">mt.find(Query.query(criteria).实体类.class);</span><br><span class="line"><span class="comment">// 先满足 and 再 or 查询</span></span><br><span class="line">mt.find(Query.query(Criteria.where(<span class="string">&quot;字段名&quot;</span>).is(<span class="string">&quot;查询条件&quot;</span>).orOperator(Criteria.where(<span class="string">&quot;字段名&quot;</span>).is(<span class="string">&quot;查询条件&quot;</span>))).实体类.class);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Query qs=<span class="keyword">new</span> <span class="title class_">Query</span>();</span><br><span class="line">qs.with(Sort.by(Sort.Order.desc(<span class="string">&quot;字段名&quot;</span>))); desc降序  asc升序</span><br><span class="line">mt.find(qs,实体类.class);</span><br><span class="line"><span class="comment">//总条数</span></span><br><span class="line">mt.count(xx);  <span class="comment">//返回符合条件的文档数</span></span><br><span class="line"><span class="comment">//去重 参数1：查询条件 2：去重字段名 3：操作集合 4：返回类型</span></span><br><span class="line">mt.findDistinct(<span class="keyword">new</span> <span class="title class_">Query</span>(),<span class="string">&quot;字段名&quot;</span>,实体类.class,返回类型);  </span><br></pre></td></tr></table></figure></li><li><p>  分页</p></li></ul><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220506171844256.png" alt="image-20220506171844256"></p><ul><li><p>使用json字符串方式查询(Query的子类BasicQuery)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicQuery</span>(<span class="string">&quot;查询条件&quot;</span>); </span><br><span class="line">eg:<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicQuery</span>(<span class="string">&quot;&#123;name:&quot;</span>xxx<span class="string">&quot;&#125;&quot;</span>); </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicQuery</span>(<span class="string">&quot;&#123;$or:[&#123;name:&quot;</span>xxx<span class="string">&quot;&#125;]&#125;&quot;</span>); </span><br><span class="line">mt.find(query,实体类.class);</span><br></pre></td></tr></table></figure></li><li><p>更新文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mt.updateFirst(查询条件,更新的内容,实体类.class);</span><br><span class="line">Update update=new Update(); update.set(&quot;字段名&quot;,value);</span><br><span class="line">mt.updateFirst(Query.query(Criteria.where(&quot;字段名&quot;).is(&quot;zzw&quot;),updata,实体类.class);   //更新符合条件的第一条</span><br><span class="line">mt.updateMulti(Query.query(Criteria.where(&quot;字段名&quot;).is(&quot;zzw&quot;),updata,实体   类.class);   //更新全部符合条件的</span><br><span class="line">mt.upsert(xxxx); //没有符合条件时插入数据</span><br><span class="line">对应的Update中有update.setOnInsert(&quot;id&quot;,1); //修改文档中的唯一标识_id</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>删除文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mt.remove(new Query(),实体类.class);  //删除所有</span><br><span class="line">mt.remove(Query.query(Criteria.where(&quot;字段名&quot;).is(&quot;zzw&quot;),实体类.class); //条件删除</span><br></pre></td></tr></table></figure></li></ul><h1 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集<Replica set></Replica></h1><p>官方中文文档:<a href="https://docs.mongoing.com/replication">https://docs.mongoing.com/replication</a></p><p>MongoDB副本集是由自动故障恢复功能的主从集群,有一个Primary节点和一个或多个Secondary节点组成。副本集没有固定的主节点,当主节点发生故障时整个集群会选举一个新的主节点为系统提供服务以保证系统的高可用。</p><h2 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移<Automatic failover></Automatic></h2><p>当主节点无法和集群中其他节点通信的时间超过参数<code>electionTimeoutMillis</code>配置的期限时（默认10s），一个候选的从节点会发起选举来推荐自己成为新主节点。集群会尝试完成一次新主节点的选举并恢复正常的操作。</p><p>可以保证数据安全的前提下实现架构高可用,但解决不了单节点的并发压力和物理上限</p><h3 id="搭建副本集"><a href="#搭建副本集" class="headerlink" title="搭建副本集"></a>搭建副本集</h3><ul><li><p>创建数据目录</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在安装目录中创建</span></span><br><span class="line">-mkdir -p /rep1/data1</span><br><span class="line">-p表示创建多级目录</span><br></pre></td></tr></table></figure></li><li><p>搭建副本集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mongod -port 27017 --dbpath=../rep1/data1 -bind_ip 0.0.0.0 --replSet myreplace/[localhost:27018,localhost:27019]</span><br><span class="line">-bind_id 开放远程连接 --replSet 指定副本集的名字和节点</span><br></pre></td></tr></table></figure></li><li><p>配置副本集，连接任意节点</p><p>use admin</p><p>初始化副本集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var config =&#123;</span><br><span class="line"> -id:&quot;myreplace&quot;,</span><br><span class="line"> member:[</span><br><span class="line">  &#123;_idL0,host:&quot;localhost:27017&quot;&#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line">rs.initiate(config); //初始化配置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk(); //设置客户端可以临时访问</span><br></pre></td></tr></table></figure></li></ul><h1 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群<sharding cluster></sharding></h1><p>官方中文文档：<a href="https://docs.mongoing.com/fen-pian">https://docs.mongoing.com/fen-pian</a></p><p>分片指的是将数据拆分，将其分散存在不同机器的过程。</p><p>分片是为了解决高并发，存储更多的数据，处理更大的负载</p><p>MongoDB分片<a href="https://docs.mongodb.com/manual/reference/glossary/#term-sharded-cluster">集群</a>包括以下组件：</p><ul><li>shard：每个shard（分片）包含被分片的数据集中的一个子集。每个分片可以被部署为<a href="https://docs.mongodb.com/manual/reference/glossary/#term-replica-set">副本集</a>架构。</li><li>mongos：<code>mongos</code>充当查询路由器，在客户端应用程序和分片集群之间提供接口。从MongoDB 4.4开始，<code>mongos</code>可以支持 <a href="https://docs.mongodb.com/manual/core/sharded-cluster-query-router/#mongos-hedged-reads">对冲读取（hedged reads）</a>以最大程度地减少延迟。</li><li>config服务器：config servers存储了分片集群的元数据和配置信息。</li></ul><h1 id="待续。。。"><a href="#待续。。。" class="headerlink" title="待续。。。"></a>待续。。。</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud</title>
      <link href="/2021/10/03/SpringCloud/"/>
      <url>/2021/10/03/SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><strong>优点：</strong>架构简单，部署成本低  </p><p><strong>缺点：</strong>耦合度高（维护困难、升级困难）</p></li><li><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><strong>优点：</strong>降低服务耦合，有利于服务升级和拓展</p><p><strong>缺点：</strong>服务调用关系错综复杂</p></li></ul><p>微服务的架构特征：</p><ul><li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</p></li><li><p>自治：团队独立、技术独立、数据独立，独立部署和交付</p></li><li><p>面向服务：服务提供统一标准的接口，与语言和技术无关</p></li><li><p>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p></li></ul><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220323213604059.png" alt="image-20220323213604059"></p><p>注意Spring Cloud和Spring Boot 有版本兼容关系(截止2022.04)</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220419163420334.png" alt="image-20220419163420334"></p><h1 id="创建Spring-Cloud项目"><a href="#创建Spring-Cloud项目" class="headerlink" title="创建Spring Cloud项目"></a>创建Spring Cloud项目</h1><p>注意在父工程的pom文件设置好Spring Cloud的版本，之后在该父工程下的微服务只需引用即可(省去重复配置的一些东西，比如mybatis、mysql、lombok)</p><p>比如一个父工程testcloud，依赖配置在<dependencyManagement>&lt;/<dependencyManagement>里面    (lombok在外面)</dependencyManagement></dependencyManagement></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;artifactId&gt;testcloud&lt;/artifactId&gt;  #父工程名</span><br><span class="line">&lt;groupId&gt;com&lt;/groupId&gt;              </span><br><span class="line">&lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;   #用pom格式打包 默认是jar</span><br><span class="line">&lt;modules&gt;                      #挂载的模块</span><br><span class="line">    &lt;module&gt;testServer&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;其他微服务&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;         #也是通过指定夫工程 来确定Spring Boot版本</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.4&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>在子工程中testServer的pom中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; #指定父工程</span><br><span class="line">    &lt;artifactId&gt;testcloud&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;artifactId&gt;testServer&lt;/artifactId&gt; #自己的工程名</span><br></pre></td></tr></table></figure><p>注意：如果不在父工程配置好，那每个子工程可能都会重复配置一些东西如Spring Cloud版本，不是不可以，就是后续微服务多起来，依赖变多，不好管理</p><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p>Eureka结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220323214259865.png" alt="image-20220323214259865"></p><p>分为服务端和客户端，两者都在父工程下</p><p><strong>order-service 如何得知 user-service 实例地址？</strong></p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li></ul><p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p><p>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</p><p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p><ul><li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，就能将故障实例排除了</li></ul><h1 id="EurekaServer服务端配置："><a href="#EurekaServer服务端配置：" class="headerlink" title="EurekaServer服务端配置："></a>EurekaServer服务端配置：</h1><ul><li><p>引入依赖  <code>spring-cloud-starter-netflix-eureka-server</code></p></li><li><p>在启动类添加@EnableEurekaServer注解</p></li><li><p>在配置文件编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">10086</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server <span class="comment">//在注册中心的服务名称</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="comment">//http://127.0.0.1:10086/eureka</span></span><br><span class="line">    register-with-eureka: <span class="literal">true</span> <span class="comment">//是否注册自己</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="EurekaClient客户端配置："><a href="#EurekaClient客户端配置：" class="headerlink" title="EurekaClient客户端配置："></a>EurekaClient客户端配置：</h1><ul><li>引入依赖   <code>spring-cloud-starter-netflix-eureka-client</code></li><li>在启动类添加@EnableEurekaServer注解(可不加，详情参考<a href="https://blog.csdn.net/sunxy24/article/details/105686511">https://blog.csdn.net/sunxy24/article/details/105686511</a>)</li><li>在配置文件编写：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: orderservice <span class="comment">//在注册中心的服务名称</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span></span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//127.0.0.1:10086/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务远程调用"><a href="#服务远程调用" class="headerlink" title="服务远程调用"></a>服务远程调用</h1><p>在服务调用类的启动类添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span> <span class="comment">//负载均衡</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/03/SpringCloud/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220419233747818.png" alt="image-20220419233747818"></p><h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220323233535532.png" alt="image-20220323233535532"></p><p>默认负载均衡是ZoneAvoidanceRule，轮询</p><p>通过定义IRule实现可以修改负责均衡规则，要在RestTemplate上添加**@LoadBalanced**</p><p>代码方式，在服务调用类的启动类中定义一个新的IRule：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;   <span class="comment">//不同策略对应不同的类名</span></span><br></pre></td></tr></table></figure><p>配置文件方式：在服务调用类的配置文件中，添加配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice(调用的服务名称):</span><br><span class="line">   ribbon:</span><br><span class="line">      NFLoadBBalancerRuleClassName: com.netflix.loadbalancer.RandonRule </span><br></pre></td></tr></table></figure><p>Ribbon默认采用懒加载，即在第一次访问时采取创建LoadBalanceClient</p><p>饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过在服务调用类的配置文件添加配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    clients: userservice  #指定对服务名称为userservice饥饿加载</span><br></pre></td></tr></table></figure><h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>在nacos的bin文件目录下命令行输入：<code>startup.cmd -m standalone</code>单机启动nacos 默认端口8848</p><p>在父工程中添加spring-cloud-alibaba管理依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.5</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在客户端添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>另外，Nacos 集群默认采用AP方式(可用性)，当集群中存在非临时实例时，采用CP模式(一致性)；而 Eureka 采用AP方式，不可切换。</strong></p><h3 id="Nacos服务分级存储-服务→集群→实例"><a href="#Nacos服务分级存储-服务→集群→实例" class="headerlink" title="Nacos服务分级存储 服务→集群→实例"></a>Nacos服务分级存储 服务→集群→实例</h3><p>在客户端添加nacos地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring：</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      discovery：</span><br><span class="line">        cluster-name：GuangZhou <span class="comment">//配置集群名称</span></span><br></pre></td></tr></table></figure><p>配置负载均衡规则,也有两种方法，配置文件和实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">iRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//默认为轮询规则，这里自定义为随机规则</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:      <span class="comment">//要做配置的微服务名称</span></span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule <span class="comment">//集群优先 然后随机</span></span><br></pre></td></tr></table></figure><h3 id="Nacos控制台可以控制实例的权重值-0-1"><a href="#Nacos控制台可以控制实例的权重值-0-1" class="headerlink" title="Nacos控制台可以控制实例的权重值(0-1)"></a>Nacos控制台可以控制实例的权重值(0-1)</h3><h2 id="环境隔离-namespace"><a href="#环境隔离-namespace" class="headerlink" title="环境隔离-namespace"></a>环境隔离-namespace</h2><p>在Nacos控制台创建namespace，用来隔离不同环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ</span><br><span class="line">        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间ID</span><br></pre></td></tr></table></figure><p>不同namespace下的服务不可见</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220326152043273.png" alt="image-20220326152043273"></p><p>服务注册到Naocs时，可以选择注册为临时或非临时实例，在配置文件添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        ephemeral: <span class="literal">false</span> /设置为非临时实例</span><br></pre></td></tr></table></figure><p>Nacos 的服务实例分为两种类型：</p><ul><li><p><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><p>在nacos控制台新建配置(注意命名空间) 格式为 name-profile.yaml</p><p>添加nacos的config依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p><p>添加bootstrap.yml，配置：服务名称、开发环境、文件后缀名，三者指定在Nacos中的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: userservice # 服务名称</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev #开发环境，这里是dev </span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span> # Nacos地址</span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml # 文件后缀名</span><br></pre></td></tr></table></figure><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><ul><li> 方式一：在@Value注入的变量所在的类上添加注解@RefreshScope</li><li>方式二：把配置注册到一个Bean对象里面<img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220328210934981.png" alt="image-20220328210934981"></li></ul><p>注意要和配置文件中的属性一一对应</p><h2 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享</h2><p>通过下面的两种方式来指定：</p><ul><li><p>extension-configs</p></li><li><p>shared-configs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml # 文件后缀名</span><br><span class="line">        extends-configs: # 多微服务间共享的配置列表</span><br><span class="line">          - dataId: common.yaml # 要共享的配置文件id</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml # 文件后缀名</span><br><span class="line">        shared-configs: # 多微服务间共享的配置列表</span><br><span class="line">          - dataId: common.yaml # 要共享的配置文件id</span><br></pre></td></tr></table></figure></li></ul><p>配置优先级：服务名-profile.yaml→服务名.yaml→本地配置</p><h1 id="Feign代替RestTemplate远程调用"><a href="#Feign代替RestTemplate远程调用" class="headerlink" title="Feign代替RestTemplate远程调用"></a>Feign代替RestTemplate远程调用</h1><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在要进行远程调用的<strong>启动类</strong>添加注解</p><p><code>@EnableFeignClients</code></p><p>编写Feign客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span> <span class="comment">//要远程调用的服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span> <span class="comment">//请求的路径</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line">通过<span class="meta">@PathVariable</span>绑定参数必须通过value属性来明确指明具体的参数名，不然会抛出异常</span><br></pre></td></tr></table></figure><p>在实现业务逻辑时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">userClient.findById(id); <span class="comment">//直接调用接口里的方法</span></span><br></pre></td></tr></table></figure><p><strong>Feign集合了Ribbon ，默认实现负载均衡</strong></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="配置Feign日志"><a href="#配置Feign日志" class="headerlink" title="配置Feign日志"></a>配置Feign日志</h2><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li></ul><p>配置文件方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      <span class="keyword">default</span>:       #<span class="keyword">default</span>默认为全局配置，如果写服务名称，则针对该服务名称进行配置</span><br><span class="line">        loggerLevel: BASIC #日志级别 none basic header full</span><br></pre></td></tr></table></figure><p>java代码方式，首先声明一个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClientConfiguration</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Logger.Level.BASIC;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局配置，<strong>启动类</strong>添加注释<code>@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)</code></p><p>局部配置，<strong>启动类</strong>添加注释<code>@FeignClient(value =&quot;服务名称&quot; ,configuration = FeignClientConfiguration)</code></p><h2 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h2><p>Feign底层的客户端实现：</p><ul><li><p>URLConnection：默认实现，不支持连接池</p></li><li><p>Apache HeepClient：支持连接池</p></li><li><p>OKHttp：支持连接池 </p></li></ul><h3 id="Feign添加HttpClient的支持："><a href="#Feign添加HttpClient的支持：" class="headerlink" title="Feign添加HttpClient的支持："></a>Feign添加HttpClient的支持：</h3><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件配置连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  httpclient:</span><br><span class="line">    enable: <span class="literal">true</span> #开关</span><br><span class="line">    max-connections: <span class="number">200</span>  #最大连接数</span><br><span class="line">    max-connections-per-route: <span class="number">50</span> #单个路径最大连接数    </span><br></pre></td></tr></table></figure><h2 id="抽取FeignClient"><a href="#抽取FeignClient" class="headerlink" title="抽取FeignClient"></a>抽取FeignClient</h2><p>创建一个module，feign-api，引入feign的依赖</p><p>里面有client、pojo、DefaultConfiguration(java代码形式)</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220401201204884.png" alt="image-20220401201204884"></p><p>当定义的FeignClient不在<strong>SpringBootAplication启动类</strong>的扫描包范围时，这些FeignClient无法使用</p><p>解决方法一：指定FeignClient所在包</p><p>启动类添加注解<code>@EnableFeignClients(basePackages = &quot;包名&quot;)</code></p><p>解决方法二：指定FeignClient字节码</p><p>启动类添加注解<code>@EnableFeignClients(clients =&#123;UserClient.class&#125;)</code></p><h1 id="统一网关Gateway"><a href="#统一网关Gateway" class="headerlink" title="统一网关Gateway"></a>统一网关Gateway</h1><p>网关功能：</p><ul><li>身份验证和权限校验</li><li>服务路由、负载均衡</li><li>请求限流</li></ul><p>在 SpringCloud 中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><p>添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--nacos服务注册发现依赖--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;!--网关gateway依赖--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置文件编写路由配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: nacos:8848 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: user-service # 路由标示，必须唯一</span><br><span class="line">          uri: lb://userservice # 路由的目标地址</span><br><span class="line">          predicates: # 路由断言，判断请求是否符合规则</span><br><span class="line">            - Path=/user/** # 路径断言，判断路径是否是以/user开头，如果是则符合</span><br><span class="line">            - After=   #断言规则</span><br><span class="line">#         filters:     # 过滤器 只针对该路由</span><br><span class="line">        - id: order-service</span><br><span class="line">          uri: lb://orderservice</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/order/**</span><br><span class="line">#      default-filters:      #  默认过滤器,会对所有的路由请求都生效</span><br><span class="line">#       - AddRequestHeader=Truth,Itcast is freaking awesome!</span><br></pre></td></tr></table></figure><p><img src="/2021/10/03/SpringCloud/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220420001323333.png" alt="image-20220420001323333"></p><h3 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h3><ul><li><p>在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory(断言工厂)读取并处理，转变为路由判断的条件</p></li><li><p>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类</p><p><img src="https://fastly.jsdelivr.net/gh/dullandmeanless/PicBed/img/image-20220407194237442.png" alt="image-20220407194237442"></p></li></ul><h2 id="路由过滤器GatewayFilter"><a href="#路由过滤器GatewayFilter" class="headerlink" title="路由过滤器GatewayFilter"></a>路由过滤器GatewayFilter</h2><p>可以对网关的请求和微服务返回的响应做处理</p><p>Spring提供了31种不同的路由过滤器工厂,<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p><p>如何在配置文件里配置,参考上面的路由配置</p><h2 id="全局过滤器GlobalFilter"><a href="#全局过滤器GlobalFilter" class="headerlink" title="全局过滤器GlobalFilter"></a>全局过滤器GlobalFilter</h2><p>处理一切进入网关的请求和微服务返回的响应,GatewayFilter通过配置定义,GlobalFilter的逻辑需要手写代码实现,定义方法是实现GlobalFilter接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="comment">//order越小优先级越高</span></span><br><span class="line"><span class="comment">// @Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取参数中的 authorization 参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.判断参数值是否等于 admin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 4.是，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.否，拦截</span></span><br><span class="line">        <span class="comment">// 5.1.设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">// 5.2.拦截请求</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器执行顺序</p><p>每一个过滤器都必须指定一个int类型的order值,order越小优先级越高</p><p>路由过滤器和默认过滤器的order由Spring指定,默认是按照声明顺序从1递增</p><p>当过滤器的order值一样值,会按照默认过滤器&gt;路由过滤器&gt;全局过滤器的顺序执行</p><h1 id="跨域问题处理"><a href="#跨域问题处理" class="headerlink" title="跨域问题处理"></a>跨域问题处理</h1><p>跨域问题:浏览器禁止请求的发起者与服务端发生跨域ajax请求,请求会被浏览器拦截,它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。</p><p>例如：a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是<strong>浏览器的限制</strong>。理解这一点很重要！！</p><p> Gateway网关处理跨域采用的同样是CORS方案,并且只需要简单配置即可实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      globalcors:  # 全局的跨域处理</span><br><span class="line">        add-to-simple-url-handler-mapping: true # 解决option请求被拦截问题</span><br><span class="line">        cors-configurations:</span><br><span class="line">          &#x27;[/**]&#x27;:</span><br><span class="line">            allowedOrigins: #允许哪些网站的跨域请求</span><br><span class="line">              - &quot;http://www.baidu.com&quot;</span><br><span class="line">              - &quot;http://localhost:8090&quot;</span><br><span class="line">            allowedMethods: #允许的跨域ajax的请求方式</span><br><span class="line">              - &quot;GET&quot;</span><br><span class="line">              - &quot;POST&quot;</span><br><span class="line">              - &quot;DELETE&quot;</span><br><span class="line">            allowedHeaders: &quot;*&quot; # 允许在请求头中携带的信息</span><br><span class="line">            allowedCredentials: true # 是否允许携带cookie</span><br><span class="line">            maxAge: 360000 #这次跨域检测的有效期</span><br></pre></td></tr></table></figure><h1 id="同步通讯和异步通讯"><a href="#同步通讯和异步通讯" class="headerlink" title="同步通讯和异步通讯"></a>同步通讯和异步通讯</h1><p><strong>微服务间通讯有同步和异步两种方式</strong></p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p>之前学习的 <strong>Feign 调用</strong>就属于<strong>同步方式</strong></p><p><strong>同步调用的优点：</strong></p><ul><li>时效性较强，可以立即得到结果</li></ul><p><strong>同步调用的缺点：</strong></p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><p>异步调用则可以避免上述问题，我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><strong>异步调用好处：</strong></p><ul><li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li><li>故障隔离：服务没有直接调用，不存在级联失败问题</li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>耦合度极低，每个服务都可以灵活插拔，可替换</li><li>流量削峰：不管发布事件的流量波动多大，都由 Broker 接收，订阅者可以按照自己的速度去处理事件</li></ul><p><strong>异步调用缺点：</strong></p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于 Broker 的可靠、安全、性能</li></ul><h2 id="RabbitMQ消息队列"><a href="#RabbitMQ消息队列" class="headerlink" title="RabbitMQ消息队列"></a>RabbitMQ消息队列</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列，也就是事件驱动架构中的 Broker</p><p>几种常见MQ的对比：</p><table><thead><tr><th align="left"></th><th align="center"><strong>RabbitMQ</strong></th><th align="center"><strong>ActiveMQ</strong></th><th align="center"><strong>RocketMQ</strong></th><th align="center"><strong>Kafka</strong></th></tr></thead><tbody><tr><td align="left">公司/社区</td><td align="center">Rabbit</td><td align="center">Apache</td><td align="center">阿里</td><td align="center">Apache</td></tr><tr><td align="left">开发语言</td><td align="center">Erlang</td><td align="center">Java</td><td align="center">Java</td><td align="center">Scala&amp;Java</td></tr><tr><td align="left">协议支持</td><td align="center">AMQP、XMPP、SMTP、STOMP</td><td align="center">OpenWire、STOMP、REST、XMPP、AMQP</td><td align="center">自定义协议</td><td align="center">自定义协议</td></tr><tr><td align="left">可用性</td><td align="center">高</td><td align="center">一般</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="left">单机吞吐量</td><td align="center">一般</td><td align="center">差</td><td align="center">高</td><td align="center">非常高</td></tr><tr><td align="left">消息延迟</td><td align="center">微秒级</td><td align="center">毫秒级</td><td align="center">毫秒级</td><td align="center">毫秒以内</td></tr><tr><td align="left">消息可靠性</td><td align="center">高</td><td align="center">一般</td><td align="center">高</td><td align="center">一般</td></tr></tbody></table><h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod = &quot;fallbackInfo&quot;)</span><br><span class="line">      public String findOrdersByUser(@PathVariable String id) &#123;</span><br><span class="line">            </span><br><span class="line">          &#125;</span><br><span class="line">      public String fallbackInfo(@PathVariable String id)&#123;</span><br><span class="line">    return &quot;服务不可用，请稍后再试！&quot;;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p> 启动类添加注解@EnableCircuitBreaker</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring、Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 开发知识</title>
      <link href="/2021/10/03/SpringBoot-dev/"/>
      <url>/2021/10/03/SpringBoot-dev/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>web环境模拟测试</p><p>@SpringBootTest(webEnvironment = SrpingBootTest.Webvironment.***) 启动虚拟环境</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220308145421445.png" alt="image-20220308145421445"></p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220308163200419.png" alt="image-20220308163200419"></p><p>生成随机数据</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220308200357559.png" alt="image-20220308200357559"></p><p>@EnableCaching启用缓存</p><p>@Cacheable(value=””,key=”#”)将当前数据加入到缓存</p><p>Quartz</p><p>Quartz的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.MyQuartz;</span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//工作明细</span></span><br><span class="line">    <span class="keyword">public</span> JobDetail <span class="title function_">jd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//MyQuartz是具体工作</span></span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(MyQuartz.class).storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//触发器将工作明细和调度器绑定 </span></span><br><span class="line">    <span class="keyword">public</span> Trigger <span class="title function_">tri</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调度器</span></span><br><span class="line">        ScheduleBuilder scheduleBuilder=CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/5 * * * * ?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger().forJob(jd()).withSchedule(scheduleBuilder).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Task</p><p>@EnableScheduling 开启定时任务功能</p><p>在要执行定时任务的方法上@Scheduled(cron =””)  在配置文件可以配task的相关配置</p><p>Spring Boot Admin 监控</p><p>在Admin Server中的启动类配置@EnableAdminServer</p><p>客户端的配置文件</p><p>management-endpoint-health-show-details：always</p><p>management-endpoint-端点名-enabled-: t/f设置端点对外开发信息</p><p>management-endpoints-web-exposure-include:”*” 将所有端点暴露给web端</p><p>Admin Server服务端通过actuator下的各种映射方法获取端点信息并展示</p><p>​           jconsole</p><p>在配置文件中为info端点配置信息</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319153708822.png" alt="image-20220319153708822"></p><p>写一个配置类AppInfoContributor为info端点增添指标信息</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319153724076.png" alt="image-20220319153724076"></p><p>同理，写一个配置类AppHealthContributor为health端点增添指标信息</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319154526544.png" alt="image-20220319154526544"></p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319160909206.png" alt="image-20220319160909206"></p><p>即在这添加具体的监听</p><p><img src="/2021/10/03/SpringBoot-dev/Users\ZZW\AppData\Roaming\Typora\typora-user-images\image-20220319161116393.png" alt="image-20220319161116393"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 运维知识</title>
      <link href="/2021/09/28/SpringBoot-om/"/>
      <url>/2021/09/28/SpringBoot-om/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot基础知识</title>
      <link href="/2021/09/26/SpringBoot-basic/"/>
      <url>/2021/09/26/SpringBoot-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot—WebMvcConfigurer详解"><a href="#SpringBoot—WebMvcConfigurer详解" class="headerlink" title="SpringBoot—WebMvcConfigurer详解"></a>SpringBoot—WebMvcConfigurer详解</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>WebMvcConfigurer配置类其实是<code>Spring</code>内部的一种配置方式，采用JavaBean的形式来代替传统的<code>xml</code>配置文件形式进行针对框架个性化定制，可以自定义一些Handler，Interceptor(拦截器)，ViewResolver(视图解析器)，MessageConverter。基于java-based方式的spring <a href="https://so.csdn.net/so/search?q=mvc&spm=1001.2101.3001.7020">mvc</a>配置，需要创建一个<strong>配置</strong>类并实现**<code>WebMvcConfigurer</code>** 接口；方式一实现WebMvcConfigurer接口（推荐），方式二继承WebMvcConfigurationSupport类，具体实现可看这篇文章。<a href="https://blog.csdn.net/fmwind/article/details/82832758">https://blog.csdn.net/fmwind/article/details/82832758</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="/2021/09/23/java/"/>
      <url>/2021/09/23/java/</url>
      
        <content type="html"><![CDATA[<p>CAP原则又称CAP定理，指的是在一个分布式系统中，<a href="https://baike.baidu.com/item/%E4%B8%80%E8%87%B4%E6%80%A7/9840083">一致性</a>（Consistency）、<a href="https://baike.baidu.com/item/%E5%8F%AF%E7%94%A8%E6%80%A7/109628">可用性</a>（Availability）、<a href="https://baike.baidu.com/item/%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7/23734073">分区容错性</a>（Partition tolerance）。CAP 原则指的是，这三个<a href="https://baike.baidu.com/item/%E8%A6%81%E7%B4%A0/5261200">要素</a>最多只能同时实现两点，不可能三者兼顾。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HexoBlog建站流程</title>
      <link href="/2021/09/21/HexoBlog/"/>
      <url>/2021/09/21/HexoBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-GitHub-搭建个人博客"><a href="#Hexo-GitHub-搭建个人博客" class="headerlink" title="Hexo+GitHub 搭建个人博客"></a>Hexo+GitHub 搭建个人博客</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>最近看到了同学写的个人网站<a href="https://magidrag0n.github.io/">https://magidrag0n.github.io/</a>  ，感觉很有意思，便打算自己也弄一个玩玩，虽然参考了同学写的教程<a href="https://magidrag0n.github.io/2020/07/16/HexoBlog-OnlineInTen/">https://magidrag0n.github.io/2020/07/16/HexoBlog-OnlineInTen/</a>   和网上的教程，但还是踩了不少雷，这里再总结一下教程，提醒自己也方便下大家。</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="GitHub-Pages-是什么？"><a href="#GitHub-Pages-是什么？" class="headerlink" title="GitHub Pages 是什么？"></a>GitHub Pages 是什么？</h3><ul><li><a href="https://link.zhihu.com/?target=https://help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h3 id="Hexo-是什么？"><a href="#Hexo-是什么？" class="headerlink" title="Hexo 是什么？"></a>Hexo 是什么？</h3><ul><li>官网：<a href="https://link.zhihu.com/?target=https://hexo.io/zh-cn/">hexo.io</a></li></ul><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><h3 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a>Hexo + GitHub 文章发布原理</h3><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>Node.js是一个让JavaScript运行在服务端的开发平台,用它可以方便地搭建响应速度快、易于扩展的网络应用</p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm(Node Package Manager)其实就是包管理工具，对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>需要用到Github账号、node.js、npm</p></li><li><p>新版的Node.js已自带npm</p><p>安装完毕后在命令行输入:node -v，检查是否成功安装、命令行中输入 npm -v，检查 npm 包管理器是否存在</p><p>如果显示’xxx’ 不是内部或外部命令，也不是可运行的程序或批处理文件时。请将node.js加入系统变量，或直接在命令前加上npx，npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。如果模块存在，就使用。如果不存在，就临时下载，用完就删除。</p></li><li><p>安装hexo博客框架</p><p>首先将命令行当前文件夹切换到一个新的空文件夹 (不建议中文) 当中</p><p>然后在命令行中输入：<code>npm install -g hexo-cli</code></p></li><li><p>安装 Git 推送套件：</p><p>在你创好的放hexo框架的文件夹中打开cmd(没特别说明后文的所有指令都是在此路径执行)，在命令行输入:<code>npm install --save hexo-deployer-git</code>。Tips：安装完成后会有一项 Warning 提醒，不用担心，敬请忽略</p></li><li><h3 id="快速开始："><a href="#快速开始：" class="headerlink" title="快速开始："></a>快速开始：</h3><p>命令行中输入：</p><p><code>hexo init</code>  (报错请尝试在前面加npx，后面所有关于hexo的命令都可以加npx)</p><p>此步骤会自动克隆一个 Landscape 的主题博客，并且你将在你的博客目录下看到自动生成的文件</p><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul></li><li><h3 id="启动本地博客服务器："><a href="#启动本地博客服务器：" class="headerlink" title="启动本地博客服务器："></a>启动本地博客服务器：</h3><p>在命令行中输入：</p><p><code>hexo generate</code>  # 生成静态页面，可以用hexo g缩写</p><p><code>hexo server</code>  # 启动预览，可以用hexo s缩写</p><p>将会提示你：</p><p><code>INFO Start processing.</code><br><code>INFO Hexo is running at http://localhost:4000.Press Ctrl+C to stop.</code></p><p>表示我们的博客已经部署到本地服务器上了，此时在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 便可查看你的博客！</p><p><img src="/2021/09/21/HexoBlog/3.jpg"></p><p>其中的自带的博文包含了一些简易的操作指令与讲解</p><p><strong>Tips：</strong>如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo s -p 5000</code> 更改端口号后重试。</p><h2 id="Hexo-的-Github-上线"><a href="#Hexo-的-Github-上线" class="headerlink" title="Hexo 的 Github 上线"></a>Hexo 的 Github 上线</h2><p>刚才建立的网站只能在本地服务器中查看，即便拿出手机输入相同网址亦是不能查看的。我们需要让好朋友们看到我们的网站，就需要将博客服务器从本地局域服务器推送到云端服务器，我们可以用GitHub Pages来完成，让所有人都可以访问。</p><ul><li><p>使用你刚才创建的Github账户，在主页右上角找到新建项目<strong>New repository</strong></p><p><img src="https://fastly.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide1.png"></p><p>并建立一个与你名称相同前缀的项目名**(YourName.github.io)**</p><p>此处因为我已经创建过所以不能重复创建，你可直接点 <strong>Create repository</strong></p><p><img src="https://fastly.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide2.png"></p><p><img src="https://fastly.jsdelivr.net/gh/MagiDrag0n/PicBed/img/2.png"></p><p>在创建好的仓库中点击Settings，选择Pages，在Source下可以选择你Github Pages所需的资源从哪里来。注:如果修改成main，在_config.yml文件末端要同步修改成branch: main。</p></li><li><h3 id="配置Git推送套件"><a href="#配置Git推送套件" class="headerlink" title="配置Git推送套件"></a>配置Git推送套件</h3><p>打开你创建的博客目录文件夹，找到_config.yml这个文件并打开编辑</p><p><img src="https://fastly.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide3.png"></p><p>在代码末尾添加：</p><p><code>deploy:</code></p><p> <code>type: &#39;git&#39;</code></p><p> <code>repo: &quot;https://github.com/你的名字/你的名字.github.io.git&quot;</code></p><p> <code>branch: &quot;master&quot;</code></p><p><img src="https://fastly.jsdelivr.net/gh/MagiDrag0n/PicBed/img/guide4.png"></p><p>至此Git推送套件已准备就绪</p><p>git有时会抽风，上传不到master分支，可以换成main分支，再修改GitHub Pages中的对应内容</p></li></ul></li><li><p>第一次使用GIt要先在命令行中输入：</p><p><code>git config --global user.email &quot;you@example.com&quot;</code>  (你的Github邮箱)<br><code>git config --global user.name &quot;Your Name&quot;</code>  (你的Github名称)</p><p>然后输入<code>hexo deploy</code> 部署文章，也可以用缩写hexo d</p><p>此时会哗啦啦流淌一行行提示，并会让你输入你的Github名称与密码</p><p>当提示结束时，便可进入网页 你的名称.github.io 查看你的博客啦！</p><p>如果输入hexo d报错，有可能是当前网络链接不太好，可以多试几次和清除代理或翻墙</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li><h3 id="博客内容的倡议"><a href="#博客内容的倡议" class="headerlink" title="博客内容的倡议"></a>博客内容的倡议</h3></li></ul><p>不能传播危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的内容。</p><p>不能散布谣言，扰乱社会秩序，破坏社会稳定。</p><p>不能散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪。</p><p>不能侮辱或者诽谤他人，侵害他人合法权益。</p><p>——《互联网信息服务管理办法》节选</p><h4 id="我们要约束自己的行为，因为这关乎所有人的互联网自由。"><a href="#我们要约束自己的行为，因为这关乎所有人的互联网自由。" class="headerlink" title="我们要约束自己的行为，因为这关乎所有人的互联网自由。"></a><strong>我们要约束自己的行为，因为这关乎所有人的互联网自由。</strong></h4><ul><li><h3 id="博客访问地址"><a href="#博客访问地址" class="headerlink" title="博客访问地址"></a>博客访问地址</h3><p><a href="https://localhost:4000/">https://localhost:4000</a>  (本地服务器开启可访问)</p><p><a href>YourName.github.io</a>  (随时随地访问最近一次推送版本的博客)</p></li><li><h3 id="常用Hexo指令"><a href="#常用Hexo指令" class="headerlink" title="常用Hexo指令"></a>常用Hexo指令</h3><p><code>hexo clean</code>  (清除缓存)</p><p><code>hexo g</code>  (迭代博客内容，每次编辑后操作)</p><p><code>hexo d</code>  (推送至github服务器)</p><p><code>hexo new page &quot;XXX&quot;</code>  (新建一个名为XXX的页面)</p><p><code>hexo new &quot;title&quot;</code>  (新建一个名为title的文章)</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
